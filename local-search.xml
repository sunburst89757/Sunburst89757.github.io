<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>react antd主题切换方案</title>
    <link href="/2023/02/01/theme/"/>
    <url>/2023/02/01/theme/</url>
    
    <content type="html"><![CDATA[<p>本文的部分实现方案可在<a href="http://47.98.204.143:3000/login">react-admin</a>(test:test)进行体验。</p><h2 id="link-标签动态引入-黑暗主题模式-和-默认主题样式"><a href="#link-标签动态引入-黑暗主题模式-和-默认主题样式" class="headerlink" title="link 标签动态引入 黑暗主题模式 和 默认主题样式"></a>link 标签动态引入 黑暗主题模式 和 默认主题样式</h2><p>通过在顶层的 link 标签进行动态引入多种不同主题的 CSS 样式文件，进行点击切换时删除之前的样式，添加选中的样式。</p><p><img src="/pic/theme/theme.png"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">changeDark</span> = (<span class="hljs-params">isDark</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;theme&quot;</span>)?.<span class="hljs-title function_">remove</span>();<br>  <span class="hljs-keyword">const</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;link&quot;</span>);<br>  link.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;theme&quot;</span>;<br>  link.<span class="hljs-property">ref</span> = <span class="hljs-string">&quot;stylesheet&quot;</span>;<br>  link.<span class="hljs-property">href</span> = isDark ? darkTheme : defaultTheme;<br>  <span class="hljs-keyword">let</span> head = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>];<br>  head.<span class="hljs-title function_">appendChild</span>(link);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* dark.scss */</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;antd/dist/antd.dark.css&quot;</span>;<br><span class="hljs-comment">/* 自定义 antd 暗黑模式样式 */</span><br>$dark-<span class="hljs-selector-tag">main</span>-bg-<span class="hljs-attribute">color</span>: <span class="hljs-number">#141414</span>;<br>$dark-bg-<span class="hljs-attribute">color</span>: <span class="hljs-number">#1f1f1f</span>;<br>$dark-<span class="hljs-attribute">border-color</span>: <span class="hljs-number">#414243</span>;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: $dark-main-bg-color <span class="hljs-meta">!important</span>;<br>  <span class="hljs-selector-class">.mainLayout</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: $dark-bg-color <span class="hljs-meta">!important</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.layoutTree</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: $dark-bg-color <span class="hljs-meta">!important</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.tagContainer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: $dark-bg-color <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">border-color</span>: $dark-border-color <span class="hljs-meta">!important</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* …… */</span><br></code></pre></td></tr></table></figure><p><img src="/pic/theme/1.png"><br><img src="/pic/theme/2.png"></p><p>两个 link 标签进行 href 引入，可以实现按需加载，但是每种主题模式需要单独维护一套 css 样式方案，新增主题或者维护主题都较为麻烦</p><h2 id="色弱模式-和-灰色模式"><a href="#色弱模式-和-灰色模式" class="headerlink" title="色弱模式 和 灰色模式"></a>色弱模式 和 灰色模式</h2><p>这两种模式都可以直接通过设置 css 属性 filter 来实现,直接给全局的 body 添加即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">changeGrayOrColorWeak</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;<br>  <span class="hljs-keyword">switch</span> (grayOrColorWeak) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gray&quot;</span>:<br>      body.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;style&quot;</span>, <span class="hljs-string">&quot;filter:grayscale(1)&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;colorWeak&quot;</span>:<br>      body.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;style&quot;</span>, <span class="hljs-string">&quot;filter:invert(80%)&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      body.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;style&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="antd-的主题色设置"><a href="#antd-的主题色设置" class="headerlink" title="antd 的主题色设置"></a>antd 的主题色设置</h2><p>antd 对主题色 分为 primary-color warning-color success-color info-color,可以通过 antd 提供的 ConfigProvider.config 这个<a href="https://4x.ant.design/components/config-provider-cn/#components-config-provider-demo-theme">API</a>来管理实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">changeThemeColor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title class_">ConfigProvider</span>.<span class="hljs-title function_">config</span>(&#123;<br>    <span class="hljs-attr">theme</span>: &#123;<br>      <span class="hljs-attr">primaryColor</span>: <span class="hljs-string">&quot;#1890ff&quot;</span>,<br>      <span class="hljs-attr">errorColor</span>: <span class="hljs-string">&quot;#ff4d4f&quot;</span>,<br>      <span class="hljs-attr">warningColor</span>: <span class="hljs-string">&quot;#faad14&quot;</span>,<br>      <span class="hljs-attr">successColor</span>: <span class="hljs-string">&quot;#52c41a&quot;</span>,<br>      <span class="hljs-attr">infoColor</span>: <span class="hljs-string">&quot;#1890ff&quot;</span>,<br>    &#125;,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="useTheme"><a href="#useTheme" class="headerlink" title="useTheme"></a>useTheme</h2><p>对主题色的设置 色弱模式 灰度模式的设置 都是对主题这一逻辑的管理，公共逻辑的管理，选择将其封装为一个 hook,所有的主题逻辑都由这套 hook 管理，控制的其余变量交给指定的 store 来维护即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ConfigProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useCallback, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useAppSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;store/types&quot;</span>;<br><span class="hljs-keyword">import</span> darkTheme <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../style/dark.scss?inline&quot;</span>;<br><span class="hljs-keyword">import</span> defaultTheme <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../style/default.scss?inline&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useTheme</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; grayOrColorWeak, isDark, grayColor, colorWeak, themeColor &#125; =<br>    <span class="hljs-title function_">useAppSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">theme</span>);<br>  <span class="hljs-keyword">const</span> changeGrayOrColorWeak = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;<br>    <span class="hljs-keyword">switch</span> (grayOrColorWeak) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gray&quot;</span>:<br>        body.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;style&quot;</span>, <span class="hljs-string">`filter:grayscale(<span class="hljs-subst">$&#123;grayColor&#125;</span>)`</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;colorWeak&quot;</span>:<br>        body.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;style&quot;</span>, <span class="hljs-string">`filter:invert(<span class="hljs-subst">$&#123;colorWeak&#125;</span>)`</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-attr">default</span>:<br>        body.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;style&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;, [grayOrColorWeak, grayColor, colorWeak]);<br>  <span class="hljs-keyword">const</span> changeDark = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;theme&quot;</span>)?.<span class="hljs-title function_">remove</span>();<br>    <span class="hljs-keyword">const</span> style = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;style&quot;</span>);<br>    style.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;theme&quot;</span>;<br>    style.<span class="hljs-property">innerHTML</span> = isDark ? darkTheme : defaultTheme;<br>    <span class="hljs-keyword">let</span> head = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>];<br>    head.<span class="hljs-title function_">appendChild</span>(style);<br>  &#125;, [isDark]);<br>  <span class="hljs-keyword">const</span> changeThemeColor = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">ConfigProvider</span>.<span class="hljs-title function_">config</span>(&#123;<br>      <span class="hljs-attr">theme</span>: themeColor,<br>    &#125;);<br>  &#125;, [themeColor]);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">changeDark</span>();<br>  &#125;, [isDark, changeDark]);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">changeGrayOrColorWeak</span>();<br>  &#125;, [grayOrColorWeak, changeGrayOrColorWeak]);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">changeThemeColor</span>();<br>  &#125;, [changeThemeColor, themeColor]);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="一个小-bug"><a href="#一个小-bug" class="headerlink" title="一个小 bug"></a>一个小 bug</h2><p>在开发过程中，我的 CSS 样式方案采用了 tailwind css，这套方案的默认样式会覆盖 antd 的部分样式，因此使用的时候需要禁止 tailwind 的预设样式,<br>在 tailwind.config.js 下添加禁止预设配置项即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// tailwind.config.js</span><br><span class="hljs-attr">corePlugins</span>: &#123;<br>  <span class="hljs-attr">preflight</span>: <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是很离谱的是，我用 tailwindcss 也开发了另一个组件，另一个组件里我并没有使用 antd，所以开发时我也没有发现，然后我在后台管理里引入了这个组件，做黑暗模式切换时就出现了 bug，每当切换到这个组件时页面整个突然的样式就离奇起来了，调试了半天发现 只有在这个组件进入时才会触发，这才发现原来是另一个组件开发时没禁止预设样式，导致打包时对新的含有 antd 的后台管理的样式造成了干扰。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>echarts在react中的使用</title>
    <link href="/2023/01/13/echarts/"/>
    <url>/2023/01/13/echarts/</url>
    
    <content type="html"><![CDATA[<p>本文的所有示例都可以在 <a href="http://47.98.204.143:3000/components/echarts">react-admin</a>(test:test)下查看体验</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>echarts 获取的 dom 结构必须要设置具体的高度或者宽度，这样 echarts 对应的 canvas 画布才有大小显示。</li><li>echarts 的有效数值<font color="red"> 必须是数值，这样才会显示正确的值</font>，比如 y &#x3D; 12(或者”12”) 而不能是”12s”这种，如果 y 轴需要带单位可以在 series 的 label 属性的 formater 进行配置单位显示。</li><li>echarts 数据集如果不设置有效的映射，那么 echarts 将根据数据集对象的键顺序判断谁是 x 轴 谁是 y 轴。 如下面的例子: value 是第一个键,那么 echarts 就将其映射为 x 轴，name 对应的就会映射到 y 轴，根据 2，有效值的地方必须是数字，所以 echarts 将不会显示图像，需要将 value 和 name 这两个键的顺序交换。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> dataset.<span class="hljs-property">source</span> = [<br>  &#123;<br>    <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;120&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;星期一&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;130&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;星期二&quot;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><ol start="4"><li>实际开发时调节 echarts 时最好直接在 echarts 提供的示例中进行修改，这样效率较高。</li><li>对于开发中需要的配置项不清楚时，可在<a href="https://echarts.apache.org/zh/cheat-sheet.html">术语速查手册</a>中根据图例快速找到配置项.</li><li>echarts 的配置项众多，建议使用 ts 的类型提示，option 的类型是 echarts.EChartsCoreOption。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">options</span>: echarts.<span class="hljs-property">EChartsCoreOption</span> = &#123;<br>  <span class="hljs-attr">title</span>: &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;饼图&quot;</span>,<br>    <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">legend</span>: &#123;<br>    <span class="hljs-attr">orient</span>: <span class="hljs-string">&quot;vertical&quot;</span>,<br>    <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;left&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">tooltip</span>: &#123;<br>    <span class="hljs-attr">trigger</span>: <span class="hljs-string">&quot;item&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">series</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;value&quot;</span>,<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;pie&quot;</span>,<br>      <span class="hljs-comment">// 饼图中radius决定大小</span><br>      <span class="hljs-attr">radius</span>: <span class="hljs-string">&quot;80%&quot;</span>,<br>      <span class="hljs-comment">// 决定图示在饼图上的位置</span><br>      <span class="hljs-comment">// label: &#123;</span><br>      <span class="hljs-comment">//   show: true,</span><br>      <span class="hljs-comment">//   position: &quot;inside&quot;,</span><br>      <span class="hljs-comment">//   formatter: (params: any) =&gt; &#123;</span><br>      <span class="hljs-comment">//     return `$&#123;params.data.name&#125;:$&#123;params.data.value&#125;`;</span><br>      <span class="hljs-comment">//   &#125;,</span><br>      <span class="hljs-comment">//   color: &quot;#fff&quot;</span><br>      <span class="hljs-comment">// &#125;,</span><br>      <span class="hljs-attr">emphasis</span>: &#123;<br>        <span class="hljs-attr">itemStyle</span>: &#123;<br>          <span class="hljs-attr">shadowBlur</span>: <span class="hljs-number">10</span>,<br>          <span class="hljs-attr">shadowOffsetX</span>: <span class="hljs-number">0</span>,<br>          <span class="hljs-attr">shadowColor</span>: <span class="hljs-string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>,<br>        &#125;,<br>      &#125;,<br>      <span class="hljs-comment">// top right 饼图在画布中的位置</span><br>      <span class="hljs-attr">top</span>: <span class="hljs-number">40</span>,<br>    &#125;,<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="echarts-数据集"><a href="#echarts-数据集" class="headerlink" title="echarts 数据集"></a>echarts 数据集</h2><p>在实际开发过程中，echarts 的样式配置实际是很少变化的，变化较多的实际是其数据，为了将数据和配置较好的分离，使用 echarts 的 <a href="https://echarts.apache.org/handbook/zh/concepts/dataset/#%E6%8A%8A%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%88-dataset-%EF%BC%89%E7%9A%84%E8%A1%8C%E6%88%96%E5%88%97%E6%98%A0%E5%B0%84%E4%B8%BA%E7%B3%BB%E5%88%97%EF%BC%88series%EF%BC%89">dataset</a> 是较为合适的方案</p><p>实际开发过程中，个人觉得采用对象数组的数据源更为符合直觉，这里以一个二维的图进行举例</p><p><img src="/pic/echarts/lineChart.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 二维数据需要设计维度dataset.dimensions</span><br><br><span class="hljs-keyword">const</span> dimensions = [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;eatMoney&quot;</span>, <span class="hljs-string">&quot;entertainmentMoney&quot;</span>];<br><br><span class="hljs-comment">// dataset.source</span><br><span class="hljs-keyword">const</span> initialLineData = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;星期一&quot;</span>,<br>    <span class="hljs-attr">eatMoney</span>: <span class="hljs-number">120</span>,<br>    <span class="hljs-attr">entertainmentMoney</span>: <span class="hljs-number">30</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;星期二&quot;</span>,<br>    <span class="hljs-attr">eatMoney</span>: <span class="hljs-number">132</span>,<br>    <span class="hljs-attr">entertainmentMoney</span>: <span class="hljs-number">25</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;星期三&quot;</span>,<br>    <span class="hljs-attr">eatMoney</span>: <span class="hljs-number">101</span>,<br>    <span class="hljs-attr">entertainmentMoney</span>: <span class="hljs-number">50</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;星期四&quot;</span>,<br>    <span class="hljs-attr">eatMoney</span>: <span class="hljs-number">134</span>,<br>    <span class="hljs-attr">entertainmentMoney</span>: <span class="hljs-number">55</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;星期五&quot;</span>,<br>    <span class="hljs-attr">eatMoney</span>: <span class="hljs-number">90</span>,<br>    <span class="hljs-attr">entertainmentMoney</span>: <span class="hljs-number">90</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;星期六&quot;</span>,<br>    <span class="hljs-attr">eatMoney</span>: <span class="hljs-number">230</span>,<br>    <span class="hljs-attr">entertainmentMoney</span>: <span class="hljs-number">88</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;星期日&quot;</span>,<br>    <span class="hljs-attr">eatMoney</span>: <span class="hljs-number">210</span>,<br>    <span class="hljs-attr">entertainmentMoney</span>: <span class="hljs-number">130</span>,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><h2 id="useEcharts-的封装"><a href="#useEcharts-的封装" class="headerlink" title="useEcharts 的封装"></a>useEcharts 的封装</h2><p>在 echarts 的使用过程中，发现每个组件在使用中都需要进行配置初始化、监听 resize 事件，在组件销毁时都要注销事件监听、在数据源发生变化时重新设置配置，因此将其选择封装为一个 hook，暴露 echarts 需要的 ref 即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;echarts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 使用Echarts(只是为了添加图表响应式)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Element</span>&#125; data 数据 目前只针对于次Hooks-admin里一些data都是写死在options 所以data为可选 根据项目自行修改即可</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; options 绘制Echarts的参数(必传)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> <span class="hljs-variable">chart</span></span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useEcharts</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  options: echarts.EChartsCoreOption,</span><br><span class="hljs-params">  data: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;[]</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> myChart = useRef&lt;echarts.<span class="hljs-property">EChartsType</span>&gt;();<br>  <span class="hljs-keyword">const</span> echartsRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">//   视图变化时 echarts也视图对应改变</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">echartsResize</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    echartsRef &amp;&amp; myChart?.<span class="hljs-property">current</span>?.<span class="hljs-title function_">resize</span>();<br>  &#125;;<br>  <span class="hljs-comment">//   数据发生变化时重新绘制</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (data?.<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>) &#123;<br>      options.<span class="hljs-property">dataset</span> || (options.<span class="hljs-property">dataset</span> = &#123;&#125;);<br>      (options.<span class="hljs-property">dataset</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;).<span class="hljs-property">source</span> = data;<br>      myChart?.<span class="hljs-property">current</span>?.<span class="hljs-title function_">setOption</span>(options);<br>    &#125;<br>  &#125;, [data, options]);<br>  <span class="hljs-comment">//   初始化设置 初始化显示 初始化事件监听 以及设置组件销毁时 移除事件监听</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (echartsRef?.<span class="hljs-property">current</span>) &#123;<br>      myChart.<span class="hljs-property">current</span> = echarts.<span class="hljs-title function_">init</span>(echartsRef.<span class="hljs-property">current</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLDivElement</span>);<br>    &#125;<br>    myChart?.<span class="hljs-property">current</span>?.<span class="hljs-title function_">setOption</span>(options);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>, echartsResize, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>, echartsResize);<br>      myChart?.<span class="hljs-property">current</span>?.<span class="hljs-title function_">dispose</span>();<br>    &#125;;<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> [echartsRef];<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>提供一个带有高度或者宽度的 html 标签 如 div</li><li>提供初始数据</li><li>提供配置</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// PieChart.tsx</span><br><span class="hljs-keyword">import</span> &#123; useEcharts &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../../hooks/useEcharts&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">options</span>: echarts.<span class="hljs-property">EChartsCoreOption</span> = &#123;<br>  <span class="hljs-attr">title</span>: &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;饼图&quot;</span>,<br>    <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">legend</span>: &#123;<br>    <span class="hljs-attr">orient</span>: <span class="hljs-string">&quot;vertical&quot;</span>,<br>    <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;left&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">tooltip</span>: &#123;<br>    <span class="hljs-attr">trigger</span>: <span class="hljs-string">&quot;item&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">series</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;value&quot;</span>,<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;pie&quot;</span>,<br>      <span class="hljs-comment">// 饼图中radius决定大小</span><br>      <span class="hljs-attr">radius</span>: <span class="hljs-string">&quot;80%&quot;</span>,<br>      <span class="hljs-comment">// 决定图示在饼图上的位置</span><br>      <span class="hljs-comment">// label: &#123;</span><br>      <span class="hljs-comment">//   show: true,</span><br>      <span class="hljs-comment">//   position: &quot;inside&quot;,</span><br>      <span class="hljs-comment">//   formatter: (params: any) =&gt; &#123;</span><br>      <span class="hljs-comment">//     return `$&#123;params.data.name&#125;:$&#123;params.data.value&#125;`;</span><br>      <span class="hljs-comment">//   &#125;,</span><br>      <span class="hljs-comment">//   color: &quot;#fff&quot;</span><br>      <span class="hljs-comment">// &#125;,</span><br>      <span class="hljs-attr">emphasis</span>: &#123;<br>        <span class="hljs-attr">itemStyle</span>: &#123;<br>          <span class="hljs-attr">shadowBlur</span>: <span class="hljs-number">10</span>,<br>          <span class="hljs-attr">shadowOffsetX</span>: <span class="hljs-number">0</span>,<br>          <span class="hljs-attr">shadowColor</span>: <span class="hljs-string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>,<br>        &#125;,<br>      &#125;,<br>      <span class="hljs-comment">// top right 饼图在画布中的位置</span><br>      <span class="hljs-attr">top</span>: <span class="hljs-number">40</span>,<br>    &#125;,<br>  ],<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">PieChart</span> = (<span class="hljs-params">&#123; data &#125;: &#123; data: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;[] &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [echartsRef] = <span class="hljs-title function_">useEcharts</span>(options, data);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;echartsRef&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;h-[80%] w-[60%] absolute bottom-0 left-6&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-comment">// App.tsx</span><br><span class="hljs-keyword">const</span> initialPieData = [<br>  &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">333</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;未派单&quot;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">221</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;已派单&quot;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">110</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;已完成&quot;</span>,<br>  &#125;,<br>];<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [pieData, setPieData] = <span class="hljs-title function_">useState</span>(initialPieData);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setPieData</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span><br>      state.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        item.<span class="hljs-property">value</span> = <span class="hljs-title function_">randomData</span>(<span class="hljs-number">20</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">return</span> item;<br>      &#125;)<br>    );<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PieChart</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;pieData&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">PieChart</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="常见的配置"><a href="#常见的配置" class="headerlink" title="常见的配置"></a>常见的配置</h2><ol><li><p>对于饼图而言 决定大小的是 series 对象下的 radius,与折线图和柱状图不同（当承载画布的大小确定的情况）</p></li><li><p>折线图 柱状图 距离画布的距离也就决定了图形的大小，是 option 下的 grid 中的 top left 等</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">grid<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    left<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3%&quot;</span><span class="hljs-punctuation">,</span><br>    right<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4%&quot;</span><span class="hljs-punctuation">,</span><br>    bottom<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3%&quot;</span><span class="hljs-punctuation">,</span><br>    containLabel<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ol start="3"><li>图示在图出现的位置，是在图上还是图外，可以由 series 下的 label 确定</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><br>series<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>   <span class="hljs-punctuation">&#123;</span><br>      name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><span class="hljs-punctuation">,</span><br>      type<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pie&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 饼图中radius决定大小</span><br>      radius<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;80%&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 决定图示在饼图上的位置</span><br>      label<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        show<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        position<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inside&quot;</span><span class="hljs-punctuation">,</span><br>        formatter<span class="hljs-punctuation">:</span> (params<span class="hljs-punctuation">:</span> any) =&gt; <span class="hljs-punctuation">&#123;</span><br>          return `$<span class="hljs-punctuation">&#123;</span>params.data.name<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span>$<span class="hljs-punctuation">&#123;</span>params.data.value<span class="hljs-punctuation">&#125;</span>`;<br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        color<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#fff&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite Plugin的一次尝试</title>
    <link href="/2022/12/27/vitePlugin/"/>
    <url>/2022/12/27/vitePlugin/</url>
    
    <content type="html"><![CDATA[<p>在上篇<a href="https://sunburst89757.github.io/2022/12/20/deploy/">docker nginx 部署 node 和前端应用</a>,在前端应用部署的过程中总是需要经过这个过程，本地打包，<br>将本地打包的资源借助<a href="https://filezilla-project.org/">FileZilla FTP Client</a>这类工具上传到服务器上 nginx 配置好的文件夹下实现前端应用的部署。</p><p>在后续开发的过程中，更新的新的前端内容总需要手动部署，总感觉有些麻烦，开始思考有没有可以采取自动化的方案来进行操作，在网上调研过一些方案，有通过 jenkins 做的部署方案，通过 github hook 在每次提交的时候 jenkins 自动进行部署，这个方案很成熟，但是这段时间正好在学习 vite，看 vite 的文档，发现 vite 的插件也可以实现这个功能。<br>整个插件的<a href="https://github.com/sunburst89757/react-admin/blob/main/vite.server.plugin.ts">源码</a>见此</p><h2 id="插件功能分析"><a href="#插件功能分析" class="headerlink" title="插件功能分析"></a>插件功能分析</h2><p>当 vite 构建的项目进行打包时，在打包的最后一个阶段将资源上传到服务器即可。</p><p>根据 vite 的官方文档和 rollup 的文档，发现 build 阶段的最后一个 hook 是 <a href="https://rollupjs.org/plugin-development/#closebundle">closeBundle</a></p><p><img src="/pic/vitePlugin/closeBundle.png"></p><ol><li>所以在 closeBundle 阶段进行上传资源到服务器的相关逻辑</li><li>上传逻辑需要连接服务器，查找到 node-ssh 这个库可以帮助进行服务器的连接，并且可以进行文件内容的上传，所以选择这个库</li></ol><h2 id="插件细节分析"><a href="#插件细节分析" class="headerlink" title="插件细节分析"></a>插件细节分析</h2><p>vite 的插件是一个函数，进行资源上传需要几个配置，服务器的 host,服务器用户 username，服务器密码 password(服务器登录私钥)，服务器需要上传文件的远程路径 remote path、以及本地打包的地址,vite 默认的打包地址是 dist,但是如果用户手动修改了打包的地址，那么也需要获取用户修改的配置，vite 提供了 configResolved 这个 hook,这个 hook 也可以读取打包的地址</p><p><img src="/pic/vitePlugin/configResolved.png"></p><p>至此，这个插件需要提供四个配置参数</p><ul><li>服务器 host</li><li>服务器用户名 username</li><li>服务器密码 password（服务器私钥）</li><li>服务器文件夹远程地址 remotePath</li></ul><p>至此整个插件的实现如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Plugin</span>, <span class="hljs-title class_">ResolvedConfig</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NodeSSH</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;node-ssh&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> serverPlugin = (&#123;<br>  host,<br>  remotePath,<br>  username,<br>  password,<br>&#125;: &#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">remotePath</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>;<br>&#125;): <span class="hljs-function"><span class="hljs-params">Plugin</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">viteConfig</span>: <span class="hljs-title class_">ResolvedConfig</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;将本地打包文件推送到服务器上的指定路径&quot;</span>,<br>    <span class="hljs-title function_">configResolved</span>(<span class="hljs-params">resolvedConfig: ResolvedConfig</span>) &#123;<br>      viteConfig = resolvedConfig;<br>    &#125;,<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">closeBundle</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> ssh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NodeSSH</span>();<br>      <span class="hljs-comment">//   连接服务器</span><br>      <span class="hljs-keyword">await</span> ssh.<span class="hljs-title function_">connect</span>(&#123;<br>        host,<br>        username,<br>        password,<br>      &#125;);<br>      <span class="hljs-comment">//   获取本地打包路径</span><br>      <span class="hljs-keyword">const</span> buildPath = path.<span class="hljs-title function_">resolve</span>(viteConfig?.<span class="hljs-property">build</span>.<span class="hljs-property">outDir</span> || <span class="hljs-string">&quot;dist&quot;</span>);<br>      <span class="hljs-comment">//   服务器上先删除remotePath下的所有文件</span><br>      <span class="hljs-keyword">await</span> ssh.<span class="hljs-title function_">execCommand</span>(<span class="hljs-string">`rm -rf <span class="hljs-subst">$&#123;remotePath&#125;</span>/*`</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将本地文件推送到服务器上</span><br>        <span class="hljs-keyword">await</span> ssh.<span class="hljs-title function_">putDirectory</span>(buildPath, remotePath, &#123;<br>          <span class="hljs-attr">concurrency</span>: <span class="hljs-number">10</span>,<br>          <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span>,<br>        &#125;);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error, <span class="hljs-string">&quot;上传错误&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 关闭服务器连接</span><br>      ssh.<span class="hljs-title function_">dispose</span>();<br>    &#125;,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@vitejs/plugin-react&quot;</span>;<br><span class="hljs-keyword">import</span> viteTsconfigPaths <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite-tsconfig-paths&quot;</span>;<br><span class="hljs-keyword">import</span> svgrPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite-plugin-svgr&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; serverPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vite.server.plugin&quot;</span>;<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">build</span>: &#123;<br>    <span class="hljs-attr">outDir</span>: <span class="hljs-string">&quot;build&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">react</span>(),<br>    <span class="hljs-title function_">viteTsconfigPaths</span>(),<br>    <span class="hljs-title function_">svgrPlugin</span>(),<br>    <span class="hljs-comment">// 使用插件</span><br>    <span class="hljs-title function_">serverPlugin</span>(&#123;<br>      <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;yourIp&quot;</span>,<br>      <span class="hljs-attr">serverPath</span>: <span class="hljs-string">&quot;/root/nginx/html&quot;</span>,<br>      <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>      <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;yourpassword&quot;</span>,<br>    &#125;),<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker nginx 部署 node 和前端应用</title>
    <link href="/2022/12/20/deploy/"/>
    <url>/2022/12/20/deploy/</url>
    
    <content type="html"><![CDATA[<p>本文是完全面向新手的，除了包括详细的部署过程外，还包括作为一个前端开发者对于初级 linux 的学习路线和资源推荐</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol><li><p><a href="http://www.ee.surrey.ac.uk/Teaching/Unix/">unix 常见操作指令</a>，两小时左右就可以看完，练习时可以使用 git bash</p></li><li><p>docker 容器技术，理解 docker 目录挂载，docker 镜像制作，docker-compose,推荐 b 站教学视频<a href="https://www.bilibili.com/video/BV11L411g7U1/?vd_source=7ebe7f72072afb765672460a71466d1a">Docker 1 小时快速上手教程，无废话纯干货</a>以及其<a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">文档</a>.</p></li><li><p>nginx 反向代理,这里主要用于对前端静态资源应用的部署，所以要求不高，只需要看懂基本的服务配置即可，推荐<a href="https://www.bilibili.com/video/BV1rG4y1e7BQ/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=7ebe7f72072afb765672460a71466d1a">nginx 一小时入门精讲课程(干货纯享版)</a>,只需看前 4p 即可。</p></li><li><p>一个连接服务器的终端，这里推荐 vscode 的 remote SSH。</p></li><li><p>一个 node 的<a href="https://github.com/sunburst89757/react-admin-backend">后端应用</a></p></li><li><p>一个 react 的<a href="https://github.com/sunburst89757/react-admin">前端应用</a></p></li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署完整的过程主要分为两步，部署前端应用和部署后端应用。</p><ol><li>使用 ssh 连接服务器，进入 root 目录,创建 admin 文件夹（后端应用上传）,创建 ngnix 文件夹，通过后续 docker-compose.yml 指定容器内的前端资源和 nginx 的配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir admin<br>mkdir nginx<br>cd nginx<br><span class="hljs-meta prompt_"># </span><span class="language-bash">前端资源文件</span><br>mkdir html<br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx配置</span><br>touch nginx.conf<br></code></pre></td></tr></table></figure><ol start="2"><li>前端应用打包,将打包的代码上传到服务器的&#x2F;root&#x2F;nginx&#x2F;html 文件夹下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm run build<br></code></pre></td></tr></table></figure><ol start="3"><li>将下列内容放于&#x2F;root&#x2F;nginx&#x2F;nginx.conf 下的 nginx 配置</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># nginx.conf</span><br><span class="hljs-comment"># 开启文件权限为root</span><br><span class="hljs-attribute">user</span>  root;<br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><span class="hljs-section">events</span> &#123;<br>  <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><span class="hljs-section">http</span> &#123;<br>  <span class="hljs-attribute">include</span>       mime.types;<br>  <span class="hljs-attribute">default_type</span>  application/octet-stream;<br>  <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>  <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br>  <span class="hljs-section">server</span> &#123;<br>      <span class="hljs-attribute">listen</span>       <span class="hljs-number">3000</span>;<br>      <span class="hljs-comment"># 一般配置域名</span><br>      <span class="hljs-attribute">server_name</span>  admin;<br>      <span class="hljs-section">location</span> / &#123;<br>          <span class="hljs-comment"># 访问3000 映射的文件路径 这里是docker内nginx的路径 前面使用docker volumn挂载过（真实代理的文件位置）</span><br>          <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>          <span class="hljs-comment"># 防止刷新页面404</span><br>          <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>          <span class="hljs-comment"># 确定首页</span><br>          <span class="hljs-attribute">index</span>  index.html;<br>      &#125;<br>      <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>      <span class="hljs-section">location</span> = /50x.html &#123;<br>          <span class="hljs-attribute">root</span>   html;<br>      &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>进入 admin，使用 git 下载 node 后端源码&#x2F;或者直接上传源代码到 admin 下,注意.env 和 keys 文件夹需要手动上传</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd admin<br>git clone https://github.com/sunburst89757/react-admin-backend<br></code></pre></td></tr></table></figure><ol start="5"><li>修改.env 中 host port 和 连接的数据库名称和密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs env">APP_HOST=yourip<br>APP_PORT=yourport<br># DATABASE_URL= &quot;mysql://root:qweasdzxc123@localhost:3306/react_admin&quot;<br>DATABASE_URL=&quot;mysql://root:yourpassword@yourip:yourport/react_admin&quot;<br><br></code></pre></td></tr></table></figure><ol start="6"><li>docker 部署镜像 一定要修改下面数据库的密码为你自己设置的密码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd react-admin-backend<br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>这里解释一下 docker 的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># docker-compose.yml</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nginx:</span> <span class="hljs-comment"># 服务名称，用户自定义</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span> <span class="hljs-comment"># 镜像版本</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3000</span><span class="hljs-string">:3000</span> <span class="hljs-comment"># 暴露端口 容器端口暴露给宿主机端口</span><br>    <span class="hljs-attr">volumes:</span> <span class="hljs-comment"># 挂载 目录挂载</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/nginx/html:/usr/share/nginx/html</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/nginx/nginx.conf:/etc/nginx/nginx.conf</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 这个必须要，解决nginx的文件调用的权限问题</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.27</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">environment:</span> <span class="hljs-comment"># 指定用户root的密码</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=yourpassword</span><br>   <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:6.2.6</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">my-redis</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">6379</span><span class="hljs-string">:6379</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">--save</span> <span class="hljs-number">20</span> <span class="hljs-number">1</span> <span class="hljs-string">--loglevel</span> <span class="hljs-string">warning</span> <span class="hljs-string">--requirepass</span> <span class="hljs-string">yourpassword</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/redis/cache:/data</span><br>  <span class="hljs-comment">#react_admin是后端服务的名称 根据当前目录下的Dockerfile生成镜像</span><br>  <span class="hljs-attr">react_admin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">admin:latest</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span> <span class="hljs-comment"># 表示以当前目录下的Dockerfile开始构建镜像</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br>    <span class="hljs-attr">depends_on:</span> <span class="hljs-comment"># 依赖与mysql、redis，其实可以不填，默认已经表示可以</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br></code></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Docker"><span class="hljs-comment"># Dockerfile</span><br><span class="hljs-comment"># 拉取node的最新镜像</span><br><span class="hljs-keyword">FROM</span> node:latest<br><span class="hljs-comment"># 设置镜像的工作目录 /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> package*.json ./</span><br><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> prisma ./prisma/</span><br><br><span class="hljs-comment"># COPY ENV variable</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> .<span class="hljs-built_in">env</span> ./</span><br><br><span class="hljs-comment"># COPY tsconfig.json file</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> tsconfig.json ./</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 根据prisma.schema 生成新的prisma client api(ts支持)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npx prisma generate</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-comment">#  以不进行类型检查的方式启动服务</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> npx ts-node-transpile-only ./src/index.ts</span><br></code></pre></td></tr></table></figure><p>注意若 docker 容器构建失败，修改 Dockerfile 或者 docker-compose.yml 解决后，使用 docker-compose build 重新构建容器，之后再使用 docker-compose up -d 启动容器</p><ol start="7"><li>数据库迁移</li></ol><ul><li>navicat 连接服务器上的 mysql yourip:3306</li><li>本地数据库通过 navicat 的转储数据库文件生成 sql 文件，服务器上的 navicat 运行生成的 sql 文件即可完成数据库数据迁移 注意：转存文件时不要转存_prisma_migration 这张表</li></ul><ol start="8"><li>至此前后端应用均已部署完成，后端应用部署到了 yourip:8080 端口，前端应用部署到 yourip:3000 端口 接着可以使用下面指令进行容器日志的查询</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs containerId<br></code></pre></td></tr></table></figure><ol start="9"><li>其他可能需要的指令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行中的容器</span><br>docker container ls<br>docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">所有的容器</span><br>docker ps -a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">所有镜像</span><br>docker images<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除镜像</span><br>docker rmi id/name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除容器</span><br>docker rm id<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器 一般修改了容器的配置文件 比如说nginx的配置</span><br>docker restart id<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看某个容器的日志</span><br>docker logs id<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统进程</span><br>systemctl status docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用rollup和typescript封装一个npm工具库</title>
    <link href="/2022/12/01/rollup/"/>
    <url>/2022/12/01/rollup/</url>
    
    <content type="html"><![CDATA[<p>前一段时间正好学习了 rollup，这次为了学有所用，以使用 rollup 封装一个 <a href="https://github.com/sunburst89757/d9lab_front_end_utils_pkg">npm 前端工具库</a>来巩固所学，该前端工具库是由实验室中常见业务功能函数构成。主要包括时间处理和科学计算。</p><h2 id="rollup-配置"><a href="#rollup-配置" class="headerlink" title="rollup 配置"></a>rollup 配置</h2><p>rollup 是一个现代 javascript 打包工具，可以将小的代码片段合成一个大的库或者应用（redux）,并且可以通过简单的配置打包多端（commonjs esmodule browser）环境。<font color = red> 使用 rollup 打包的库必须使用 es module 不可以使用 commonjs 或者其他模块化方式 </font></p><p>对于一个打包工具而言，显然需要入口(input)和出口(output)，为了在打包过程中插入一些特定操作，这也就有了插件(plugin)。对于不同的输出格式，常见的如 commonjs 、 es module 、浏览器格式 iife。 这三种输出只需要在 output 配置项配置 format 即可。</p><ol><li>常用插件的使用场景</li></ol><ul><li>如果编写的库文件中使用了第三方库（库默认是 commonjs 模块化），想将第三方库打包进源代码里，可以使用 @rollup&#x2F;plugin-node-resolve 插件。</li><li>如果编译打包的场景需要对编译的 js 有较高的向下兼容性要求，可以使用@rollup&#x2F;plugin-babel 配置常见的预设环境 preset-env</li><li>如果对编译打包的代码要压缩处理，可以使用@rollup&#x2F;plugin-terser</li><li>如果库文件由 typescript 编写，可以使用@rollup&#x2F;plugin-typescript 作为 rollup 和 tsc 的桥梁进行打包处理，默认会读取 tsconfig.json 的配置。</li></ul><ol start="2"><li><p>external 配置项：将第三方库打包到源代码里不是一个很好的选择，配置 external 后可以默认在安装该 npm 包时，会自动下载对应的 第三方包。配置就是键值对的形式，以 dayjs 为例，键是包的名字 值是 dayjs 默认导出的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">external</span>: &#123;<br>    <span class="hljs-attr">dayjs</span>: <span class="hljs-string">&quot;dayjs&quot;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>但是这种配置方式不是很合理，如果引用的第三包较多时，一个个手动配置就很麻烦了，可以直接引入 package.json 里的 dependencies 字段里的值就可以解决了，使用这种方式一定要注意，区分开发依赖和服务依赖的安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<br><span class="hljs-keyword">const</span> pkg = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./package.json&quot;</span>));<br><span class="hljs-keyword">const</span> external = [...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(pkg.<span class="hljs-property">dependencies</span> || &#123;&#125;)].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span><br>  <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^<span class="hljs-subst">$&#123;name&#125;</span>($|/)`</span>)<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">input</span>: <span class="hljs-string">&quot;./index.ts&quot;</span>,<br>  <span class="hljs-attr">output</span>: [<br>    &#123;<br>      <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;./dist/bundle.es.mjs&quot;</span>,<br>      <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;es&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;./dist/bundle.common.js&quot;</span>,<br>      <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>    &#125;,<br>  ],<br>  external,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>解决 ts 打包成 js 并且 对 js 做降级兼容处理的方案，bable 和 tsc 都可以处理这个问题，这里选择了 tsc 的方案，选择使用@rollup&#x2F;plugin-typescript 作 rollup 和 tsc 的桥梁，生成声明文件并且将编译打包的源代码作 es5 兼容处理。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 编译后的js代码是es5格式</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES5&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 编写的ts源代码可以使用最新的ts特性</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ESNext&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 以node寻找文件的方式 所以可以省略扩展名.ts</span><br>    <span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;allowJs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 生成.d.ts声明文件</span><br>    <span class="hljs-attr">&quot;declaration&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 明确声明文件生成的文件夹</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skipLibCheck&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lib&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ES2016&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;DOM&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;resolveJsonModule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;lib/**/*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;index.ts&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;node_modules&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;dist&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>结合 ts 处理 压缩代码处理 完整的配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup&quot;</span>;<br><span class="hljs-keyword">import</span> typescript <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@rollup/plugin-typescript&quot;</span>;<br><span class="hljs-keyword">import</span> terser <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@rollup/plugin-terser&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<br><span class="hljs-keyword">const</span> pkg = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./package.json&quot;</span>));<br><span class="hljs-keyword">const</span> external = [...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(pkg.<span class="hljs-property">dependencies</span> || &#123;&#125;)].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span><br>  <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^<span class="hljs-subst">$&#123;name&#125;</span>($|/)`</span>)<br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">input</span>: <span class="hljs-string">&quot;./index.ts&quot;</span>,<br>  <span class="hljs-attr">output</span>: [<br>    &#123;<br>      <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;./dist/bundle.es.mjs&quot;</span>,<br>      <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;es&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;./dist/bundle.common.js&quot;</span>,<br>      <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>    &#125;,<br>  ],<br>  external,<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">typescript</span>(), <span class="hljs-title function_">terser</span>()],<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h2 id="package-json-的两个配置项"><a href="#package-json-的两个配置项" class="headerlink" title="package.json 的两个配置项"></a>package.json 的两个配置项</h2><ol><li><p>main 属性： main 是 npm 包的入口文件，npm 包主要是存在于 node 环境中，所以 main 配置的文件应是 rollup 以 commonjs 格式打包的 bundle.common.js。</p></li><li><p>module 属性： module 并不是 npm 官方 规定的格式，但是对于由 rollup 和 webpack 构建的环境下，这些构建工具会扫描 package.json 属性里的 module 属性，如果 module 属性里有值，那么构建环境中使用 es module 的形式引入 npm 包就会引入 module 属性配置的文件。所以 module 配置项存放的应该是 rollup 以 es 格式打包的 bundle.es.mjs。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  d9lab_front_end_utils_pkg这个库文件</span><br><span class="hljs-comment">//  rollup.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">input</span>: <span class="hljs-string">&quot;./index.ts&quot;</span>,<br>  <span class="hljs-attr">output</span>: [<br>    &#123;<br>      <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;./dist/bundle.es.mjs&quot;</span>,<br>      <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;es&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;./dist/bundle.common.js&quot;</span>,<br>      <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>    &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//d9lab_front_end_utils_pkg这个库文件</span><br><span class="hljs-comment">// package.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/bundle.common.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/bundle.es.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/index.d.ts&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// commonjs 环境使用  d9lab_front_end_utils_pkg</span><br><span class="hljs-comment">//  这里d9lab_front_end_utils指向的是上述配置文件中的bundle.common.js</span><br><span class="hljs-keyword">const</span> &#123; transferTime &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;d9lab_front_end_utils_pkg&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// es module使用</span><br><span class="hljs-comment">//这里d9lab_front_end_utils指向的是上述配置文件中的bundle.es.js</span><br><span class="hljs-keyword">import</span> &#123; transferTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;d9lab_front_end_utils_pkg&quot;</span>;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发过程中跨域的解决方案</title>
    <link href="/2022/11/16/crossOrigin/"/>
    <url>/2022/11/16/crossOrigin/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么会出现跨域"><a href="#为什么会出现跨域" class="headerlink" title="为什么会出现跨域"></a>为什么会出现跨域</h2><p>在前端开发的过程中，在使用 ajax 向后端发送请求经常会出现这样一种情况。<br><img src="/pic/crossOrigin/1.png"><br>这种现象是浏览器的同源策略导致的，同源策略是浏览器的核心基础安全策略。</p><h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><p>同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><p>如果两个 URL 的 protocol、port 和 host 都相同的话，则这两个 URL 是同源。但凡其中一个存在不同的时候，就违反了同源策略，浏览器将会拦截这次请求的结果（但实际上后台服务器是接收到了这次请求并作出了响应，只是浏览器拦截了请求的结果。）</p><p>下图给出了与 URL <a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a> 的源进行对比的示例：</p><p><img src="/pic/crossOrigin/2.png"></p><p>因此出于浏览器同源策略的影响，不是同源的两个 URI 进行请求时就会出现跨域的问题。<br>目前真正的解决方案往往是部署时由服务端来通过、比如配置 CORS，nginx 方向代理解决，但在开发阶段，作为前端工程师在前后端分离的项目里可以使用配置反向代理来解决该问题。</p><h2 id="反向代理的原理"><a href="#反向代理的原理" class="headerlink" title="反向代理的原理"></a>反向代理的原理</h2><p>我们以浏览器的服务是 <a href="http://localhost:3000/">http://localhost:3000</a> 后台服务器的服务是 <a href="http://localhost:8080/">http://localhost:8080</a> 为例分析，由于二者 URI 的端口不同，违反了同源策略，所以在 3000 端口的服务发起的 ajax 请求就会因为违反浏览器的同源策略而拒绝访问。</p><p><img src="/pic/crossOrigin/3.png"></p><p>但是同源的策略仅针对浏览器与服务器之间存在，我们可以在浏览器和服务器之间建立一个代理服务器来作桥梁 ，现在我们给代理服务器取 A 真正的后台服务器取 B，<br>设置的服务器 A 的协议端口与浏览器的服务一致，这样就避免了同源策略的拦截，并且服务器 A 与服务器 B 之间是不存在同源拦截的，因此，从浏览器发出请求是向 A 发送，A 立即向 B 发送请求，B 的返回值会直接给服务器 A，因为不存在同源所以不会拦截，B 服务器与浏览器的 URL 同源，故而也不会拦截，这样就解决了浏览器跨域拦截的问题。<br><img src="/pic/crossOrigin/4.png"></p><p>现在大多数的项目都是前后端分离的项目，前端项目往往都是如 webpack 或者 vite 构建的项目，笔者大多是在 webpack 配置，故以 webpack 配置方法为例</p><h2 id="webpack-配置代理服务器"><a href="#webpack-配置代理服务器" class="headerlink" title="webpack 配置代理服务器"></a>webpack 配置代理服务器</h2><p>大多数框架的配置都是 webpack 的，因此这里以 webpack 配置为例进行讲解，对于具体的框架可以查询如 vue-cli 如何配置 webpack react 同理</p><p>proxy 配置就是 webpack 提供的代理服务器的配置项,使用&#x2F;api 这个路由映射真正的后台服务器。</p><ul><li>target: 是目标服务器真正的后台服务器的地址</li><li>pathRewrite: 重写请求路径中的&#x2F;api 为空</li><li>changeOrigin 设置为 true 是应对 如果后台服务器也进行了同源校验，如果真正的后台服务开启了同源校验 ，设置为 true 可以欺骗真正后台服务器 8080 代理服务器也是 8080 的，但实际上代理服务器其实是在 3000 端口的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:8080&quot;</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&quot;^/api&quot;</span>: <span class="hljs-string">&quot;&quot;</span> &#125;,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// ajax请求 --- 映射的路由是 http://localhost:8080/api/login</span><br><span class="hljs-comment">// 但实际上服务器上是没有api的因此webpack下所以要配置pathRewrite将api这个路由进行重写&quot;&quot;</span><br><span class="hljs-comment">// 这时完整的映射是http://localhost:8080/login</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/login&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建二叉树的方法</title>
    <link href="/2022/11/11/constructBinaryTree/"/>
    <url>/2022/11/11/constructBinaryTree/</url>
    
    <content type="html"><![CDATA[<p>二叉树是天然的递归结构</p><h2 id="已知两种遍历构建二叉树的三种情况"><a href="#已知两种遍历构建二叉树的三种情况" class="headerlink" title="已知两种遍历构建二叉树的三种情况"></a>已知两种遍历构建二叉树的三种情况</h2>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的通用思考范式</title>
    <link href="/2022/11/02/binaryTree/"/>
    <url>/2022/11/02/binaryTree/</url>
    
    <content type="html"><![CDATA[<p>二叉树是天然的递归结构</p><h2 id="递归的通用解决"><a href="#递归的通用解决" class="headerlink" title="递归的通用解决"></a>递归的通用解决</h2><h2 id="遍历函数-外层变量"><a href="#遍历函数-外层变量" class="headerlink" title="遍历函数+外层变量"></a>遍历函数+外层变量</h2><h2 id="分解子问题"><a href="#分解子问题" class="headerlink" title="分解子问题"></a>分解子问题</h2>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react 性能优化的三个API</title>
    <link href="/2022/10/28/performanceOptimise/"/>
    <url>/2022/10/28/performanceOptimise/</url>
    
    <content type="html"><![CDATA[<h2 id="memo-函数"><a href="#memo-函数" class="headerlink" title="memo 函数"></a>memo 函数</h2><h2 id="useCallBack"><a href="#useCallBack" class="headerlink" title="useCallBack"></a>useCallBack</h2><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react中useEffect的使用</title>
    <link href="/2022/10/15/useEffect/"/>
    <url>/2022/10/15/useEffect/</url>
    
    <content type="html"><![CDATA[<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><h2 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h2><h2 id="尽量减少-useEffect-的使用"><a href="#尽量减少-useEffect-的使用" class="headerlink" title="尽量减少 useEffect 的使用"></a>尽量减少 useEffect 的使用</h2><h2 id="解决竞态条件"><a href="#解决竞态条件" class="headerlink" title="解决竞态条件"></a>解决竞态条件</h2>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise静态方法</title>
    <link href="/2022/09/25/promise/"/>
    <url>/2022/09/25/promise/</url>
    
    <content type="html"><![CDATA[<p>关于 Promise 的易错理解及四种静态方法 all allSettled race any 的实现方法。</p><h2 id="Promise-的理解"><a href="#Promise-的理解" class="headerlink" title="Promise 的理解"></a>Promise 的理解</h2><ol><li>Promise 总共有三种状态，分别是 Pending Fulfilled Rejected 三种状态，状态流转只能是单向的，只能由 Pending–&gt;Fulfilled 或者 Pending–&gt;Rejected.</li><li>Promise 实例化对象上的 then 只是取出 Promise 的值而已，并不是执行 Promise，Promise 执行的时候是在实例化对象的时候就已经进行了。</li><li>Promise 实例化的对象上 then 方法 return 的值会自动被 Promise 包裹，因此 Promise 会形成链式调用。</li><li>catch 方法实际上是 Promise 实例对象上的第二个参数（错误捕获的回调函数）的语法糖。</li><li>all allSettled race any 都是 Promise 这个类的静态方法只能由<code>Promise.all</code>这样调用，不是在实例化的对象上调用。</li></ol><h2 id="all-方法"><a href="#all-方法" class="headerlink" title="all 方法"></a>all 方法</h2><ol><li>作用：接收一组值，用数组存储，返回一个 Promise 对象，当 Promise 中没有 reject 的值时，将所有 promise resolve 的值存储到数组里，通过 then 的第一个回调取出。只要出现 reject 就立刻 catch</li><li>注意事项：<ul><li><font color = red>接收的值可以是 Promise 也可以不是 Promise</font>，函数会自动将非 Promise 的值转化为 Promise。</li><li>所有 Promise 都执行了，then 方法只是进行了取值操作</li></ul></li><li>实现注意细节<ul><li>必须对入参进行数组校验</li><li>入参可以不是 Promise 但要对非 Promise 的值进行包裹成为 Promise</li><li>输出的结果的顺序得和入参的顺序保持一致</li></ul></li><li>测试时候建议将 ts 注释删除使用 js 在浏览器内测试</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseAll</span>(<span class="hljs-params">arr: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 入参必须保证是数组</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;传参必须是数组&quot;</span>));<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">values</span>: <span class="hljs-built_in">any</span>[] = [];<br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//    传递的参数可以不是Promise 但得经过Promise包装</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 数组输出的结果和入参的Promise顺序得一致</span><br>          values[index] = res;<br>          counter++;<br>          <span class="hljs-comment">//只有所有的Promise都resolve了之后才返回值</span><br>          <span class="hljs-keyword">if</span> (counter === arr.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(values);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">//    一个Promise出错了reject</span><br>          <span class="hljs-title function_">reject</span>(err);<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1000</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;err:2000&quot;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;前面失败了但是promise依然执行&quot;</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3000</span>);<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><span class="hljs-keyword">const</span> p4 = <span class="hljs-string">&quot;非Promise值&quot;</span>;<br><span class="hljs-title function_">promiseAll</span>([p3, p4, p1])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>  &#125;);<br><br><span class="hljs-comment">/* promiseAll([p3, p2, p4, p1])</span><br><span class="hljs-comment">  .then((res) =&gt; &#123;</span><br><span class="hljs-comment">    console.log(&quot;res:&quot;, res);</span><br><span class="hljs-comment">  &#125;)</span><br><span class="hljs-comment">  .catch((err) =&gt; &#123;</span><br><span class="hljs-comment">    console.log(err);</span><br><span class="hljs-comment">  &#125;); */</span><br></code></pre></td></tr></table></figure><h2 id="allSettled-方法"><a href="#allSettled-方法" class="headerlink" title="allSettled 方法"></a>allSettled 方法</h2><p>allSettled 是为了解决 all 方法的缺陷产生的，主要解决的是不论是否 reject 都把对应的值存起来，因此它没有 catch 方法。</p><p>同样的注意事项与 all 相同的不在赘述，只是 allSettled 特别的需要注意没有 reject，因为所有的 promise 值都分为状态保存都 resolve 出去了。还有一点就是<font color = red>Promise.allSettled 不会捕获 throw new Error 的错误</font></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseAllSettled</span>(<span class="hljs-params">arr: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 入参必须保证是数组</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;传参必须是数组&quot;</span>));<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">values</span>: <span class="hljs-built_in">any</span>[] = [];<br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//    传递的参数可以不是Promise 但得经过Promise包装</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 数组输出的结果和入参的Promise顺序得一致</span><br>          values[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;fulfilled&quot;</span>, <span class="hljs-attr">value</span>: res &#125;;<br>          counter++;<br>          <span class="hljs-comment">//所有Promise执行完成后 才resolve</span><br>          <span class="hljs-keyword">if</span> (counter === arr.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(values);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          values[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;rejected&quot;</span>, <span class="hljs-attr">reason</span>: err &#125;;<br>          counter++;<br>          <span class="hljs-comment">//所有Promise执行完成后 才resolve 没有catch捕获错误</span><br>          <span class="hljs-keyword">if</span> (counter === arr.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(values);<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="race-方法"><a href="#race-方法" class="headerlink" title="race 方法"></a>race 方法</h2><p>race 是竞速的意思，最快的 promise 解决或者拒绝的时候 Promise.all 的 promise 就解决或者拒绝</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseRace</span>(<span class="hljs-params">arr: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 入参必须保证是数组</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;传参必须是数组&quot;</span>));<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//    传递的参数可以不是Promise 但得经过Promise包装</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 数组输出的结果和入参的Promise顺序得一致</span><br><br>          <span class="hljs-comment">//所有Promise执行完成后 才resolve</span><br>          <span class="hljs-title function_">resolve</span>(res);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">//所有Promise执行完成后 才resolve 没有catch捕获错误</span><br>          <span class="hljs-title function_">reject</span>(err);<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="any-方法"><a href="#any-方法" class="headerlink" title="any 方法"></a>any 方法</h2><p>any 是为了解决 race 的缺陷，当第一个 promise 解决的时候才 resolve。不论前面是否有 promise 拒绝，只有当所有 promise 都拒绝，才 rejecte</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseAny</span>(<span class="hljs-params">arr: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 入参必须保证是数组</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;传参必须是数组&quot;</span>));<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">reasons</span>: <span class="hljs-built_in">any</span>[] = [];<br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//    传递的参数可以不是Promise 但得经过Promise包装</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">//一旦有promise解决就resolve</span><br>          <span class="hljs-title function_">resolve</span>(res);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          counter++;<br>          reasons[index] = err;<br>          <span class="hljs-comment">//所有Promise都reject 才reject</span><br>          <span class="hljs-keyword">if</span> (counter === arr.<span class="hljs-property">length</span>) <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(reasons));<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程师命令行终端指南</title>
    <link href="/2022/09/23/shell/"/>
    <url>/2022/09/23/shell/</url>
    
    <content type="html"><![CDATA[<p>本文主要是站在一个前端工程师的角度学习一些常用的终端命令，以提升工作效率，这篇文章主要是参考<a href="https://www.joshwcomeau.com/javascript/terminal-for-js-devs/">The Front-End Developer’s Guide to the Terminal</a>，在此基础上结合实际开发经历添加了一些个人见解。</p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><p>作者主要使用 windows 开发，所以本文主要是在 windows 上的终端使用的，其他平台不能保证成功。作者使用的终端工具是 <a href="https://git-scm.com/download/win">git bash</a>,常用 IDE 是 Vscode，主要是将 Vscode 的终端工具默认设置为 git bash，主要在 Vscode 的终端进行开发使用,本文的所有终端命令也都是建立在 git bash 上进行的。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>打开 Vscode 终端可以发现首行会出现一个$符号，这表明终端等待你输入一个命令,命令输入完毕后按回车表明命令执行，命令执行完毕后终端会另起一行继续出现$,如果没有出现$表明上一条命令没有执行完毕。</p><p>在终端里输入<code>echo &quot;hello world&quot;</code> 按回车。<br><img src="/pic/shell/1.png"></p><p>echo 指令类似于前端 js 中常用的<code>console.log()</code></p><h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><p>终端主要的目的是可以让我们在文件系统中进行四处浏览和打开&#x2F;运行某些东西，只是在 windows 上我们之前都是用 GUI 界面进行操作的，现在是在终端中使用 shell 命令进行操作而已。这里介绍一些常见的命令。</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>pwd（Print Working Directoy）: 打印当前工作目录，表示的是你当前所在的文件位置<br><img src="/pic/shell/2.png"><br>当前我所处的工作目录就是 g 盘</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>ls（list）： 表示的是当前工作目录下的文件列表，其中高亮的表示是文件夹，颜色较浅的就是单文件<br><img src="/pic/shell/3.png"></p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>cd（Change Directoy）：表明切换当前工作目录，cd 可以接两种形式的命令，一种是相对路径，一种是绝对路径。</p><ol><li>相对路径<ul><li><code>.</code> 一个 dot 表示是当前工作目录</li><li><code>..</code>两个 dot 表示是当前工作目录的父级目录</li></ul></li><li>绝对路径： cd 直接跟路径名即可，使用绝对路径是有一个很常见的问题就是如果路径很长，得手动输入路径，这要求很高而且很容易出错，这时有一个小技巧就是 Tab 键，可以书写路径时结合 Tab 键进行联想，终端会自动补全，比如说下图中的去 test 目录，输入一个 te 后按 Tab 就能够自动补全路径。（注意，如果输入的已知路径存在重名，Tab 会推导失败）。</li></ol><p>其中在 git bash 里 <code>~</code>表示的是系统用户根目录<br><img src="/pic/shell/4.png"></p><h3 id="mkdir-x2F-touch"><a href="#mkdir-x2F-touch" class="headerlink" title="mkdir&#x2F;touch"></a>mkdir&#x2F;touch</h3><p>mkdir 创建文件夹<br>touch 创建文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir stuff // 创建stuff文件夹<br>cd stuff<br>touch a.txt // 创建a.txt文件<br></code></pre></td></tr></table></figure><h2 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h2><p>Flags 可以增强某些指令的能力，比如 rm 命令，rm 是删除单个文件的指令,如下删除了 test3 文件<br><img src="/pic/shell/5.png"></p><h3 id="rf"><a href="#rf" class="headerlink" title="rf"></a>rf</h3><p>但是 rm 默认情况下是不能删除文件夹的，但是可以通过 r flag 改变这种规则, 表示的是 递归（recursive）,它会递归删除 test 文件夹内的所有东西，包括文件夹本身，这个 flag 常和 flag f（-f,–force）结合一起使用,<code>rm -rf something</code>强制递归删除文件夹内的所有东西包括它本身<br><img src="/pic/shell/6.png"><br><font color = red>谨慎使用<code>rm -rf something</code>,这个命令不会有确认删除的提示，而且删除的内容不会出现在回收站内，一旦数据删除不可找回</font></p><h3 id="la"><a href="#la" class="headerlink" title="la"></a>la</h3><p>另一个很常见的命令<code>ls</code> 经常会结合两个 flags</p><ul><li><code>l</code>表示”long”,将打印用更详细的数据打印目录内容，包括创键时间修改时间等信息</li><li><code>a</code>表示”all”,打印所有的文件，包括隐藏的文件（windows 的资源管理器会默认隐藏一些文件）<br><img src="/pic/shell/7.png"></li></ul><h2 id="终止命令"><a href="#终止命令" class="headerlink" title="终止命令"></a>终止命令</h2><p>有时候一些进程是长期执行的，有时候需要中断，一个很常见得场景是本地开启的一个开发服务器进行 Vue 或者 React 开发时，不在开启应用时需要终止这个进程。可以使用<code>ctrl + c</code>,有时候如果<code>ctrl + c</code>不奏效可以使用<code>ctrl + d</code></p><p>如果进入了 Vim 模式的话，退出编辑模式使用<code>ESC</code>，按住<code>:q</code>可以退出模式，编辑后想保存退出使用<code>:wq</code></p><h2 id="常见开发时使用的命令"><a href="#常见开发时使用的命令" class="headerlink" title="常见开发时使用的命令"></a>常见开发时使用的命令</h2><p>前文主要讲述的是如何用终端做事情的一般计算的例子。下面讲述的是前端工程师经常需要使用的命令。</p><h3 id="管理依赖"><a href="#管理依赖" class="headerlink" title="管理依赖"></a>管理依赖</h3><p>第一次接手项目时，通过 git 下载源代码后第一件事就是下载依赖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd path/to/project<br>npm install<br></code></pre></td></tr></table></figure><h3 id="运行-npm-脚本"><a href="#运行-npm-脚本" class="headerlink" title="运行 npm 脚本"></a>运行 npm 脚本</h3><p>开发过程中，有时候想快速运行一些第三方库的命令，并统一到 npm script 时就会用到，常见的如测试命令，部署命令，提交命令等等，这些都在 package.json 的 scripts 字段里进行配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts start&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts test&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eject&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts eject&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cz</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>这些命令可以通过<code>npm run [name]</code>执行，比如启动开发服务器<code> npm run start</code></p><h3 id="打开-IDE"><a href="#打开-IDE" class="headerlink" title="打开 IDE"></a>打开 IDE</h3><p>vscode 在 windows 默认安装下就会自动添加<code>code</code>命令，用于将当前工作目录使用 vscode 打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /path/to/project<br><span class="hljs-meta prompt_"># </span><span class="language-bash">. 表示当前工作目录</span><br>code .<br></code></pre></td></tr></table></figure><h3 id="重新安装依赖"><a href="#重新安装依赖" class="headerlink" title="重新安装依赖"></a>重新安装依赖</h3><p>有时候因为依赖的问题导致项目出现异常，可能需要卸载依赖后重新安装这时候可以执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd path/to/project<br>rm -rf node_modules<br>npm install<br></code></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>有时候也会结合 git 进行使用，下面是常用的 git 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> Download a Git repository onto</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> your <span class="hljs-built_in">local</span> machine</span><br>git clone [URL]<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Check <span class="hljs-built_in">which</span> files have been modified</span><br>git status -s<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> View changes</span><br>git diff<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Stage all files</span><br>git add .<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Commit staged files</span><br>git commit -m &quot;Short descriptive message&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Create a new <span class="hljs-built_in">local</span> branch</span><br>git switch -c [new branch name]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Switch branches</span><br>git switch [branch name]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Push your code to Github (or wherever</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> the project lives)</span><br>git push origin [branch name]<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Start an interactive rebase</span><br>git rebase -i [branch name or commit hash]<br></code></pre></td></tr></table></figure><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>下面是一些常用的小技巧，可以显著的提高命令行使用效率的小技巧</p><h3 id="循环切换命令"><a href="#循环切换命令" class="headerlink" title="循环切换命令"></a>循环切换命令</h3><p>有时候想快速频繁切换刚刚使用过的命令可以借助键盘上的上下箭头按键快速切换当前终端中历史的命令。</p><h3 id="清空终端"><a href="#清空终端" class="headerlink" title="清空终端"></a>清空终端</h3><p>有时候终端的信息太长，有些已经不需要看了可以使用<code>ctrl + l</code>快捷键或者使用<code>clear</code>命令实现清楚终端信息，这一点在 chrome 的 dev tools 里同样适用。</p><h3 id="alias-别名"><a href="#alias-别名" class="headerlink" title="alias 别名"></a>alias 别名</h3><p>有时候 shell 本身的命令比较复杂难记，自己使用的时候想借助别名，使用别名来代替原来的命令，使用方式如下：使用 open 代替 start 命令，start 是以 GUI 的形式打开某个目录。<font color = red>注意等号前后不能有空格</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias open=&quot;start&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> 打开当前目录</span><br>open .<br></code></pre></td></tr></table></figure><h3 id="链式命令"><a href="#链式命令" class="headerlink" title="链式命令"></a>链式命令</h3><p>有时候想实现一个命令执行完后自动执行另一个命令，这种场景很常见：安装好依赖后开启开发服务器，这种实现形式是用<code>&amp;&amp;</code>拼接两个命令</p><p><code>npm install &amp;&amp; npm run start</code></p><p><code>git add . &amp;&amp; git commit -m &quot;Stuff&quot; &amp;&amp; git push origin main</code></p>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的响应式原理</title>
    <link href="/2022/09/16/reactive/"/>
    <url>/2022/09/16/reactive/</url>
    
    <content type="html"><![CDATA[<p>Vue3 的响应式是借助 ES6 新增的 Proxy 和 Reflect 实现的，本文先介绍 Proxy 和 Reflect 的基本操作，再介绍 Vue3 的响应式</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ol><li>Proxy 是 ES6 新增的代理对象，借助这个代理对象可以实现对<font color = red>代理对象(不是源对象)</font>的拦截和自定义操作如：对对象属性的读、写、删除等操作进行拦截和自定义，这些操作被称为捕获器(trap),总计有 13 种捕获器。</li><li>基本使用<ul><li>proxyObj 代理对象的键值对与源对象完全相同</li><li>Proxy 对象接收两个参数<code>target</code> <code>handler</code>,target 是源对象，准备代理的对象，hanler 对象是用于捕获器的对象。</li><li>上例中使用的 handler 对象使用了 get 捕获器，<font color = red>代理对象</font>对属性进行读的操作会触发这个捕获器</li><li>get 捕获器接收三个参数分别是<code>target</code>：源对象，<code>key</code>:源对象的键，<code>receiver</code>:代理对象 proxyObj</li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cy&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target === obj);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver === proxyObj); <span class="hljs-comment">// true</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被读`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// name属性被读</span><br><span class="hljs-comment">// cy</span><br></code></pre></td></tr></table></figure><ol start="3"><li>常见的其它捕获器</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cy&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被读`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被写`</span>);<br>    <span class="hljs-keyword">return</span> (target[key] = value);<br>  &#125;,<br>  <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被删除了`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>  <span class="hljs-comment">//    拦截in操作符</span><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key);<br>  &#125;,<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj.<span class="hljs-property">name</span>);<br>proxyObj.<span class="hljs-property">age</span> = <span class="hljs-number">24</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj.<span class="hljs-property">age</span>);<br><span class="hljs-keyword">delete</span> proxyObj.<span class="hljs-property">age</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> proxyObj);<br></code></pre></td></tr></table></figure><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><ol><li>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。<font color=red>这些方法与 proxy handlers 的方法相同</font>。Reflect 不是一个函数对象，因此它是不可构造的，直接使用即可。</li><li>使用场景<ul><li>最主要的场景是和 Proxy 的捕获器一起使用</li><li>代替原来在 Object 上的部分方法</li></ul></li><li>基本使用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> duck = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Maurice&quot;</span>,<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>,<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Quaaaack! My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(duck, <span class="hljs-string">&quot;color&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ol start="4"><li>结合 Proxy 基本使用:将上面例子中直接操作源对象改成使用 Reflect 上的方法即可</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cy&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被读`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被写`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被删除了`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>  <span class="hljs-comment">//    拦截in操作符</span><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key);<br>  &#125;,<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj.<span class="hljs-property">name</span>);<br>proxyObj.<span class="hljs-property">age</span> = <span class="hljs-number">24</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj.<span class="hljs-property">age</span>);<br><span class="hljs-keyword">delete</span> proxyObj.<span class="hljs-property">age</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> proxyObj);<br></code></pre></td></tr></table></figure><h2 id="Vue3-响应式"><a href="#Vue3-响应式" class="headerlink" title="Vue3 响应式"></a>Vue3 响应式</h2><ol><li>响应式定义：所谓的响应式就是某一个状态发生变化时能够自动监视到对应的变化，并且执行某些操作，在 vue 中就是当 reactive 的响应式对象，对象的属性的值发生变化，就会执行页面的渲染操作，导致页面重新渲染。</li><li>设计原则<ul><li>对象的属性发生变化，执行某些操作，也就是函数，可以借助 Proxy 对象进行属性监听</li><li>执行的这些函数区别于普通的函数，<font color=red>也就是说这些函数应该都有对这些属性进行有读的操作</font>，也就是响应式的函数，也就是需要和对应的属性进行绑定，<font color = red>这些函数可以称之为这些响应式属性的依赖，这些函数需要有标识</font><ul><li>每一个属性都存在自己的依赖，都会进行依赖存储和依赖执行操作，有自己的属性和两个对应的操作(方法)，可以考虑封装一个依赖类 Depend</li><li><font color = red>只有读操作的函数才会是响应式的函数，响应式也就是说，当属性改变的时候，函数就会执行，什么样的函数呢？当然是使用了这些属性的地方（也就是读）才会重新执行</font></li><li><font color = red>依赖中执行两个操作，一个是收集依赖函数，一个是执行依赖函数，读取这些属性的函数就是依赖函数（只有当属性改变的时候，这些读这些属性的地方才会重新执行渲染）</font><ul><li>读属性的地方进行收集依赖函数</li><li>写属性的地方进行执行依赖函数</li></ul></li></ul></li><li>一个对象有许多不同的属性，不同的属性应该都有自己对应的执行函数，所以说属性和对应的依赖应该存在一个映射关系，这里用 Map 来存储对应关系</li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IFunc</span> = <span class="hljs-function">(<span class="hljs-params">...res: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-attr">reactiveFns</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">IFunc</span>&gt;;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 不应该执行几次响应式函数就添加几次依赖，多次相同的函数应该只添加一次，所以可以用set</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">IFunc</span>&gt;();<br>  &#125;<br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn: IFunc</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(fn);<br>  &#125;<br>  <span class="hljs-comment">// 执行响应式函数</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cy&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Depend</span>&gt;();<br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, receiver</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(key)) &#123;<br>      map.<span class="hljs-title function_">set</span>(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>());<br>    &#125;<br>    <span class="hljs-comment">//  执行依赖函数时也需要读取属性 这时候reactiveFn就是null了 不添加依赖</span><br>    reactiveFn &amp;&amp; map.<span class="hljs-title function_">get</span>(key)?.<span class="hljs-title function_">addDepend</span>(reactiveFn);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, value, receiver</span>) &#123;<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br>    <span class="hljs-comment">// 修改属性应该执行这些依赖函数</span><br>    map.<span class="hljs-title function_">get</span>(key)?.<span class="hljs-title function_">notify</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>&#125;);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">reactiveFn</span>: <span class="hljs-title class_">IFunc</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn: IFunc</span>) &#123;<br>  reactiveFn = fn;<br>  <span class="hljs-comment">//   响应式函数执行  执行期间会进行依赖收集</span><br>  <span class="hljs-title function_">fn</span>();<br>  <span class="hljs-comment">//    执行完毕后清</span><br>  reactiveFn = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;name的依赖函数&quot;</span>);<br>&#125;);<br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age的依赖函数&quot;</span>);<br>&#125;);<br>objProxy.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>上述的设计还有值得优化的地方，可以从以下角度进行优化<ul><li>一个组件有多个对象是响应式的，这里使用 WeakMap 存储所有的映射关系，因为 WeakMap 是弱引用，当响应式对象想销毁时，直接赋值为 null 即可，不会因为 WeakMap 的影响而影响 GC 回收。</li><li>对收集依赖的地方进行函数统一封装</li><li>对 addDepend 进行优化</li><li>响应式对象的映射关系如下图<br><img src="/pic/reactive/reactive.png"></li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IFunc</span> = <span class="hljs-function">(<span class="hljs-params">...res: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">reactiveFn</span>: <span class="hljs-title class_">IFunc</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-attr">reactiveFns</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">IFunc</span>&gt;;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 不应该执行几次响应式函数就添加几次依赖，多次相同的函数应该只添加一次，所以可以用set</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">IFunc</span>&gt;();<br>  &#125;<br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//  执行依赖函数时也需要读取属性 这时候reactiveFn就是null了 不添加依赖</span><br>    reactiveFn &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(reactiveFn);<br>  &#125;<br>  <span class="hljs-comment">// 执行响应式函数</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cy&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,<br>&#125;;<br><span class="hljs-comment">//  组件的总响应式对象 键是一个个响应式对象 值是响应式对象对应的map</span><br><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;, <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Depend</span>&gt;&gt;();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;, key: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!targetMap.<span class="hljs-title function_">has</span>(target)) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Depend</span>&gt;();<br>    targetMap.<span class="hljs-title function_">set</span>(target, map);<br>  &#125;<br>  <span class="hljs-keyword">const</span> map = targetMap.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!map?.<span class="hljs-title function_">has</span>(key)) &#123;<br>    <span class="hljs-keyword">const</span> depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();<br>    map?.<span class="hljs-title function_">set</span>(key, depend);<br>  &#125;<br>  <span class="hljs-keyword">return</span> map?.<span class="hljs-title function_">get</span>(key);<br>&#125;<br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);<br>    depend?.<span class="hljs-title function_">addDepend</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, value, receiver</span>) &#123;<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br>    <span class="hljs-comment">// 修改属性应该执行这些依赖函数</span><br>    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);<br>    depend?.<span class="hljs-title function_">notify</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>&#125;);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn: IFunc</span>) &#123;<br>  reactiveFn = fn;<br>  <span class="hljs-comment">//   响应式函数执行  执行期间会进行依赖收集</span><br>  <span class="hljs-title function_">fn</span>();<br>  <span class="hljs-comment">//    执行完毕后清</span><br>  reactiveFn = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;name的依赖函数&quot;</span>);<br>&#125;);<br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age的依赖函数&quot;</span>);<br>&#125;);<br>objProxy.<span class="hljs-property">age</span> = <span class="hljs-number">23</span>;<br>objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;tyz&quot;</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li>封装响应式函数：类似 Vue3 封装一个 reactive 函数，传入一个对象，得到的对象就是响应式的对象</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IFunc</span> = <span class="hljs-function">(<span class="hljs-params">...res: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">reactiveFn</span>: <span class="hljs-title class_">IFunc</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-attr">reactiveFns</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">IFunc</span>&gt;;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 不应该执行几次响应式函数就添加几次依赖，多次相同的函数应该只添加一次，所以可以用set</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">IFunc</span>&gt;();<br>  &#125;<br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//  执行依赖函数时也需要读取属性 这时候reactiveFn就是null了 不添加依赖</span><br>    reactiveFn &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(reactiveFn);<br>  &#125;<br>  <span class="hljs-comment">// 执行响应式函数</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//  组件的总响应式对象 键是一个个响应式对象 值是响应式对象对应的map</span><br><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;, <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Depend</span>&gt;&gt;();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;, key: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!targetMap.<span class="hljs-title function_">has</span>(target)) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Depend</span>&gt;();<br>    targetMap.<span class="hljs-title function_">set</span>(target, map);<br>  &#125;<br>  <span class="hljs-keyword">const</span> map = targetMap.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!map?.<span class="hljs-title function_">has</span>(key)) &#123;<br>    <span class="hljs-keyword">const</span> depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();<br>    map?.<span class="hljs-title function_">set</span>(key, depend);<br>  &#125;<br>  <span class="hljs-keyword">return</span> map?.<span class="hljs-title function_">get</span>(key);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn: IFunc</span>) &#123;<br>  reactiveFn = fn;<br>  <span class="hljs-title function_">fn</span>();<br>  reactiveFn = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);<br>      depend?.<span class="hljs-title function_">addDepend</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key: <span class="hljs-built_in">string</span>, value, receiver</span>) &#123;<br>      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br>      <span class="hljs-comment">// 修改属性应该执行这些依赖函数</span><br>      <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;修改属性------------&quot;</span>);<br><br>      depend?.<span class="hljs-title function_">notify</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">const</span> info = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cy&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,<br>&#125;);<br><span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;info&quot;</span>);<br>&#125;);<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;info&quot;</span>);<br>&#125;);<br><span class="hljs-keyword">const</span> info2 = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;tyz&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,<br>&#125;);<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info2.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;info2&quot;</span>);<br>&#125;);<br>info.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;tyz&quot;</span>;<br><br>info2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;cy&quot;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo fluid搭建教程</title>
    <link href="/2022/09/03/blog-build/"/>
    <url>/2022/09/03/blog-build/</url>
    
    <content type="html"><![CDATA[<p><a href="https://laosu.ml/2022/01/24/%E7%94%A8GitHub%20Actions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/?highlight=github+action">https://laosu.ml/2022/01/24/%E7%94%A8GitHub%20Actions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/?highlight=github+action</a></p><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/</a></p><p><a href="https://hexo.fluid-dev.com/posts/actions-deploy/">https://hexo.fluid-dev.com/posts/actions-deploy/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js面向对象的实现---由ES5到ES6</title>
    <link href="/2022/08/29/prototype/"/>
    <url>/2022/08/29/prototype/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>es6 之前，js 实现面向对象的方法是借助构造函数实现的</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li>每一个对象都有自己的隐式原型对象 <code>[[prototype]]</code> ,浏览器环境和 node 都会提供一个 API <code>__proto__</code>属性让开发者访问到该对象上的原型对象,但是该 API 可能会存在一定的兼容性问题，本文都用 <code>__proto__</code>属性代替 <code>[[prototype]]</code></li><li>每一个函数都有自己的显示原型对象 <code>prototype</code>,这是 ECMAScript 实现的,不存在兼容性问题,<font color = "red">注意箭头函数没有 <code>prototype</code>，因此不能用于构造函数</font></li></ol><ul><li>函数的显示原型中存在一个属性<code>constructor</code>是一个函数指向它本身</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p><img src="/pic/prototype/1.png"></p><ol start="3"><li>函数也是一个对象，所以函数是既有显示原型对象也有隐式原型对象的。</li></ol><h3 id="new-构造函数发生了什么"><a href="#new-构造函数发生了什么" class="headerlink" title="new 构造函数发生了什么"></a>new 构造函数发生了什么</h3><ol><li>在 new 构造函数的时候内存中执行了以下事件</li></ol><ul><li>创建了一个空对象 <code>&#123;&#125;</code></li><li>将 this 绑定在这个空对象上</li><li>将函数的<code>prototype</code>属性赋值给这个对象的隐式原型 <code>__proto__</code>上</li><li>执行函数体中的代码</li><li>将 this 这个对象返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eating&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><p><img src="/pic/prototype/2.png"></p><ol start="2"><li>在用字面量声明一个对象的时候本质上是 <code>new Object()</code> 的一个语法糖，因此 Object 这个函数的 <code>prototype</code> 就给了 obj 这个对象的隐式原型 <code>__proto__</code><br>这里字面量的<code>__proto__</code>就是顶层原型了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// 对象的顶层原型</span><br></code></pre></td></tr></table></figure><p><img src="/pic/prototype/3.png"></p><ol start="3"><li>函数也是一个对象，因此它也有自己的隐式原型<code>__proto__</code>,来自于<code>new Function()</code>的<code>Function.prototype</code>，函数也有自己的显式原型<code>prototype</code>,函数的显示原型是 js 引擎创建的一个对象里面有<code>constructor</code>属性,显示原型<code>prototype</code>是一个对象因此也有<code>__proto__</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">//  prototype也是一个对象也有__proto__ 对象的__proto__是new Object()而来，所以是Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><ol start="4"><li>顶层 Function 和顶层 Object 之间的关系</li></ol><ul><li>Function 是一个函数，因此 Function.prototype 存在 constructor 指向自己 Function</li><li>Function 也是一个对象，<code>Function.__proto__</code>是由 <code>new Function()</code> 而来所以 <code>Function.__proto__</code>指向 <code>Function.prototype</code></li><li>Function 的 prototype 也是一个对象，因此也存在<code>__proto__</code>,对象是 new Object()而来，因此<code>Function.prototype.__proto__ === Object.prototype</code></li><li>function Object 是一个函数，所以存在自己的原型对象 prototype</li><li>Object 也是一个对象，所以有自己的隐式原型<code>__proto__</code>是 new Function 而来，所以<code>Object.__proto__ === Function.prototype</code><br><img src="/pic/prototype/7.png"></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  prototype也是一个对象也有__proto__ 对象的__proto__是new Object()而来，所以是Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">__proto__</span> === foo.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 对象顶层原型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="构造函数封装类"><a href="#构造函数封装类" class="headerlink" title="构造函数封装类"></a>构造函数封装类</h2><p>前文对于构造函数的封装，存在不妥之处，主要在于类中方法的实现,当用这个构造函数实现多个实例时可以发现，不同实例上的 eat 方法本应该没有区别，但是在这种方式下实现时，每一个实例的 eat 方法占用了不同的内存空间，也就是说实例化的时候开辟了多余的内存空间对内存造成了很大的浪费。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eating&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tyz&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">eat</span> === p1.<span class="hljs-property">eat</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>那么我们该如何优化呢？这时候我们就可以考虑借助到原型了，将方法挂载到每一个类的原型上，并不是直接挂载到对象的属性本身上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eat&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tyz&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">eat</span> === p1.<span class="hljs-property">eat</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>为什么呢？方法（函数）在内存中实际上引用的是一个地址 Perosn 的原型对象上一个属性 eat 存储了一个方法，那么在 new 实例时将 prototype 这个对象的地址给了 p 这个对象的<strong>proto</strong>， 调用实际的方法是指向的同一个地址，因此就不会造成内存空间的浪费了。</p><p><img src="/pic/prototype/4.png"></p><h2 id="构造函数实现继承"><a href="#构造函数实现继承" class="headerlink" title="构造函数实现继承"></a>构造函数实现继承</h2><h3 id="属性的继承"><a href="#属性的继承" class="headerlink" title="属性的继承"></a>属性的继承</h3><p>通过 Person.call 可以实现属性的继承 Person 本身就是一个函数，使用 call 方法将 Student 内部创建的 this 绑定上去即可实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eat&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, sno</span>) &#123;<br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>  <span class="hljs-comment">/* </span><br><span class="hljs-comment">  本质实现了下面的语句</span><br><span class="hljs-comment">  this.name = name;</span><br><span class="hljs-comment">  this.age = age;</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法的继承"><a href="#方法的继承" class="headerlink" title="方法的继承"></a>方法的继承</h3><p>一个很常见的想法是直接将<code>Child.prototype</code> 指向<code>Father.prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eat&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, sno</span>) &#123;<br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;<br>&#125;<br><span class="hljs-comment">//  Object.create创建了一个新对象&#123;&#125; &#123;&#125;.__proto__ = Person.prototype的复制体</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;1102&quot;</span>);<br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;0729&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">eat</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">__proto__</span> === s1.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>但是这种实现方式表面上看实现了继承，但实际上每一个实例化的对象的原型都指向了<code>Person.prototype</code>,这样给 Student 添加的方法最终都会添加到 Father.prototype 这实际上是违背了面向对象的原则的。因此真正的方法是使用<code>Child.prototype</code>指向一个全新的对象，这个对象的原型是<code>Father.prototype</code>的副本，由于本来实例化的对象的原型是 Student.prototype，但是现在是直接使用 Object.create()创造的对象替换了原来的对象，因此 Student.prototype 就缺少了 constructor 这个函数，所以也需要补上。内存图解如下<br><img src="/pic/prototype/6.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eat&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, sno</span>) &#123;<br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;<br>&#125;<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Student</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;1102&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br></code></pre></td></tr></table></figure><p><img src="/pic/prototype/5.png"></p><p>为了实现的通用性，将继承函数封装一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritProto</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>  subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">value</span>: subType,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eat&quot;</span>);<br>&#125;;<br><span class="hljs-title function_">inheritProto</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, sno</span>) &#123;<br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="class-实现面向对象"><a href="#class-实现面向对象" class="headerlink" title="class 实现面向对象"></a>class 实现面向对象</h2><p>class 是构造函数的语法糖</p><h3 id="new-class-发生了什么"><a href="#new-class-发生了什么" class="headerlink" title="new class 发生了什么"></a>new class 发生了什么</h3><p>new class 自动执行了 constructor 函数，执行了以下步骤</p><ul><li>创建一个空对象</li><li>将 Person.prototype 赋值给（指向）空对象的<strong>proto</strong></li><li>将 this 绑定给空对象</li><li>执行代码</li><li>将 this 对象返回</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//  类是构造函数的语法糖</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">_address</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    constructor 执行的时机： new Person时执行</span><br><span class="hljs-comment">    1. 创建一个空对象</span><br><span class="hljs-comment">    2. 将Person.prototype赋值给（指向）空对象的__proto__</span><br><span class="hljs-comment">    3. 将this绑定给空对象</span><br><span class="hljs-comment">    4. 执行代码</span><br><span class="hljs-comment">    5. 将this返回 </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-comment">// 静态属性 ，外界不直接访问，修改, 约定的，但是实际操作可以读取，但是不建议</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span> = <span class="hljs-string">&quot;广州&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">//   普通方法</span><br>  <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;eating&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//   类的访问器方法 ---- vue 中双向绑定原理</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">address</span>() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取address&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">address</span>(<span class="hljs-params">newVal: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;修改address&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span> = newVal;<br>  &#125;<br>  <span class="hljs-comment">//   类中的静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">personMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;静态方法，构造函数（类）调用，实例不能调用&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((p <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br>p.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;hhh&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">address</span>);<br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">personMethod</span>();<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>使用关键字 extends 和 super 实现继承</p><ul><li><code>super()</code>直接调用，在<code>constructor</code>内部，用于调用父类的<code>constructor</code>,实现属性继承</li><li>super 也可以调用父类的方法，实现子类部分方法的逻辑的重写或者复用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person1</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">_address</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-comment">// 静态属性 ，外界不直接访问，修改, 约定的，但是实际操作可以读取，但是不建议</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span> = <span class="hljs-string">&quot;广州&quot;</span>;<br>  &#125;<br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; sleeping&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//   普通方法</span><br>  <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eating&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//   类的访问器方法 ---- vue 中双向绑定原理</span><br>  <span class="hljs-comment">//   get address() &#123;</span><br>  <span class="hljs-comment">//     console.log(&quot;读取address&quot;);</span><br>  <span class="hljs-comment">//     return this._address;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   set address(newVal: string) &#123;</span><br>  <span class="hljs-comment">//     console.log(&quot;修改address&quot;);</span><br>  <span class="hljs-comment">//     this._address = newVal;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   类中的静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">personMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;静态方法，构造函数（类）调用，实例不能调用&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person1</span> &#123;<br>  <span class="hljs-attr">sno</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, sno: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-comment">// 调用父类的constructor</span><br>    <span class="hljs-variable language_">super</span>(name, age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;<br>  &#125;<br>  <span class="hljs-title function_">learn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;learning&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//    重写父类中的eat方法</span><br>  <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 调用父类的eat ，使用父类的eat方法逻辑 但还继续添加逻辑</span><br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">eat</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;新增student 的eat逻辑&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//    也可以重写父类的静态方法</span><br>&#125;<br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>, <span class="hljs-number">112</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br>s.<span class="hljs-title function_">eat</span>();<br>s.<span class="hljs-title function_">sleep</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>js高级系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios封装</title>
    <link href="/2022/08/06/axios/"/>
    <url>/2022/08/06/axios/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中，也被 Vue 官方推荐用于作请求库来使用，本文根据曾经项目里的实际需求和结合文章阅读做出的 axios 封装，以下是文件结构<br><img src="/pic/axios/file.png"><br>鉴于类具有更好的封装性质，所以使用 class 来封装。</p><h2 id="通用拦截器封装"><a href="#通用拦截器封装" class="headerlink" title="通用拦截器封装"></a>通用拦截器封装</h2><p>通用拦截器说明每一个实例化的请求都具有这个通用的拦截器，因此需要在 constructor 内部实现，实例化 axios 后直接挂载对应的拦截器。用于所有 http 请求都需要的通用拦截。</p><ul><li>用于登录失效后刷新登录：响应拦截器</li><li>用于实现全局请求的 load 效果：请求拦截、响应拦截</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRequest</span> &#123;<br>  <span class="hljs-attr">service</span>: <span class="hljs-title class_">AxiosInstance</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: AxiosRequestConfig</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span> = axios.<span class="hljs-title function_">create</span>(config);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(&quot;所有实例都请求拦截成功&quot;);</span><br>        <span class="hljs-keyword">return</span> config;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(err, &quot;所有实例都请求拦截失败&quot;);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">res: AxiosResponse</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(res, &quot;公共响应拦截成功&quot;);</span><br>        <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特殊拦截器封装"><a href="#特殊拦截器封装" class="headerlink" title="特殊拦截器封装"></a>特殊拦截器封装</h2><p>对于不同的服务器配置的 axios 可能需要有对应特殊的拦截需要在传入实例时进行配置，所以对传入的 config 进行扩展，支持传入特殊的请求拦截和响应拦截。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptors</span> &#123;<br>  requestSuccess?: <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> <span class="hljs-title class_">AxiosRequestConfig</span>;<br>  requestErr?: <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br>  responseSuccess?: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> = <span class="hljs-string">AxiosResponse</span>&gt;</span>(res: T) =&gt; T;</span><br><span class="language-xml">  responseErr?: (err: any) =&gt; any;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml"></span><br><span class="language-xml">interface RequestConfig extends AxiosRequestConfig &#123;</span><br><span class="language-xml">  interceptors?: Interceptors;</span><br><span class="language-xml">  successMsg?: string;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>同样的对于整个向服务器发送请求的拦截也是在实例化的瞬间就完成，故而也是封装在 constructor 内部的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRequest</span> &#123;<br>  <span class="hljs-attr">service</span>: <span class="hljs-title class_">AxiosInstance</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: RequestConfig</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span> = axios.<span class="hljs-title function_">create</span>(config);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(&quot;所有实例都请求拦截成功&quot;);</span><br>        <span class="hljs-keyword">return</span> config;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(err, &quot;所有实例都请求拦截失败&quot;);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>    <span class="hljs-comment">// 不同实例的请求拦截器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestSuccess</span>,<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestErr</span><br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">res: AxiosResponse</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>    <span class="hljs-comment">// 不同实例的响应拦截器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseSuccess</span>,<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseErr</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单个请求的拦截"><a href="#单个请求的拦截" class="headerlink" title="单个请求的拦截"></a>单个请求的拦截</h2><p>对于某些单个请求有时候需要做定制化的需求，比如说单独需要查看某个请求的进度条的使用情况，就需要对单个请求进行拦截。<br>单个请求的拦截就必须对 axios 的 request 请求进行拦截，需要单独封装实现方法。对于单个请求 axios 没有直接提供对应的拦截器 api 函数，需要自己实现。</p><ul><li>请求拦截本质上是在真正请求发生前对 config 做的操作，这里的方法本就是在请求发生前执行的操作，故而只需在 axios 的 request 方法执行前对 config 进行操作即可。</li><li>响应拦截：只需在获取响应后对其修改后再传递出去即可，这时需要借助 Promise,封装请求函数的时候返回 Promise，将修改好的 res 值在 resolve 出去即可实现响应拦截的效果。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts">request&lt;T = <span class="hljs-title class_">IMyResponse</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 这个return才是真正执行请求，在执行请求前进行请求拦截--目的就是改变config</span><br>    <span class="hljs-keyword">if</span> (config?.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestSuccess</span>) &#123;<br>      config = config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">requestSuccess</span>(config);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span><br>        .<span class="hljs-property">request</span>&lt;<span class="hljs-built_in">any</span>, T&gt;(config)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 响应成功的拦截</span><br>          <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseSuccess</span>) &#123;<br>            res = config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseSuccess</span>&lt;T&gt;(res);<br>          &#125;<br>          <span class="hljs-title function_">resolve</span>(res);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseErr</span>) &#123;<br>            err = config.<span class="hljs-property">interceptors</span>?.<span class="hljs-title function_">responseErr</span>(err);<br>          &#125;<br>          <span class="hljs-title function_">reject</span>(err);<br>        &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="axios-配置和导出"><a href="#axios-配置和导出" class="headerlink" title="axios 配置和导出"></a>axios 配置和导出</h2><p>建议配置文件和导出文件分离，有助于后续修改。</p><ul><li>配置文件提供 axios 通用配置比如 baseUrl timeout 等</li><li>导出文件暴露配置好的 axios 和通用的请求方法便于下一步单个请求函数的封装</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// config</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BASE_URL</span> = <span class="hljs-string">&quot;http://example.com&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span> = &#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-variable constant_">BASE_URL</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">interceptors</span>: &#123;<br>    <span class="hljs-attr">requestSuccess</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;特有的请求拦截成功&quot;</span>);<br>      <span class="hljs-keyword">return</span> config;<br>    &#125;,<br>    <span class="hljs-attr">requestErr</span>: <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err, <span class="hljs-string">&quot;特有的请求拦截失败&quot;</span>);<br>    &#125;,<br>    <span class="hljs-attr">responseSuccess</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;特有的响应拦截成功&quot;</span>, res);<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;,<br>    <span class="hljs-attr">responseErr</span>: <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;特有的响应拦截失败&quot;</span>, err);<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 完整的接口返回成功的话一般返回以下四个参数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyResponse</span>&lt;T = <span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>  <span class="hljs-attr">success</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImyRequest</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestConfig</span> &#123;<br>  <span class="hljs-comment">// RequestConfig里有data，这里再写一次是为了使用传入泛型的方法来约束data类型</span><br>  data?: T;<br>&#125;<br><span class="hljs-keyword">const</span> service = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRequest</span>(instanceConfig);<br><span class="hljs-comment">// 该请求方式默认为GET，且一直用data作为参数(条件解决了)；</span><br><span class="hljs-comment">// T是真正的请求函数发出的参数的类型</span><br><span class="hljs-comment">// V是请求返回体的data的类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> myRequest&lt;T, V = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">ImyRequest</span>&lt;T&gt;) &#123;<br>  <span class="hljs-keyword">const</span> &#123; method = <span class="hljs-string">&quot;GET&quot;</span> &#125; = config;<br>  <span class="hljs-keyword">if</span> (method === <span class="hljs-string">&quot;get&quot;</span> || method === <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>    config.<span class="hljs-property">params</span> = config.<span class="hljs-property">data</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> service.<span class="hljs-property">request</span>&lt;<span class="hljs-title class_">IMyResponse</span>&lt;V&gt;&gt;(config);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数级-api-封装"><a href="#函数级-api-封装" class="headerlink" title="函数级 api 封装"></a>函数级 api 封装</h2><p>对于 API 的封装建议使用单独的 API 文件夹管理，不同模块单独文件夹管理，每个页面单独 ts 文件管理，这样具体使用的时候直接引用对应的方法即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; myRequest &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../service&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">IUserInfo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/types&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> requestParams &#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Res</span> &#123;<br>  <span class="hljs-attr">token</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">nickName</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">params: requestParams</span>) &#123;<br>  <span class="hljs-keyword">return</span> myRequest&lt;requestParams, <span class="hljs-title class_">Res</span>&gt;(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/login/login&quot;</span>,<br>    params,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>    <span class="hljs-attr">successMsg</span>: <span class="hljs-string">&quot;登录成功&quot;</span>,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref在react中的使用</title>
    <link href="/2022/08/04/ref/"/>
    <url>/2022/08/04/ref/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="ref-的使用场景"><a href="#ref-的使用场景" class="headerlink" title="ref 的使用场景"></a>ref 的使用场景</h2><p>根据官方文档，ref 变量的值由 react 来维护，但是 ref 的值的变化并不会触发页面的重新渲染，因此 ref 的值实际上主要有两种使用场景。</p><ol><li>维护需要变化但是不影响页面渲染的值。</li><li>用于获取 DOM 实现父组件调用子组件的方法。</li></ol><h2 id="使用-ref-进行接口的查询"><a href="#使用-ref-进行接口的查询" class="headerlink" title="使用 ref 进行接口的查询"></a>使用 ref 进行接口的查询</h2><p>一个很常见的场景：查表业务中，更改了每页显示的数量后立刻调接口刷新页面数据,实现如下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_">useState</span>(……);<br><span class="hljs-keyword">const</span> handleChangePageSize = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setFormData</span>(formData)<br>  <span class="hljs-title function_">getDataList</span>()<br>&#125;, []);<br><span class="hljs-keyword">const</span> getDataList = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-title function_">fetchData</span>(formData)<br>  &#125;,<br>  [],<br>)<br><br></code></pre></td></tr></table></figure><p>实现的时候经常会出现页面数据仍然是上次的结果，查看 formData 确实是 set 过之后的结果，原因是 setData 引发的渲染 react 做的是批量更新的处理，是等所有的 state 都更新过后才会执行，所以 fetchData 拿到的数据是上一次渲染前的数据，因此页面的数据不会更新。</p><p>出现的问题是由于两次渲染前后 state 的变化导致的，那么我们就可以选择一个不影响渲染但是有 react 维护的值来存储查表业务即可实现，这时可以使用 ref 来保存查表需要的参数，state 用来维护页面的状态不参与查表的业务即可实现。实现如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_">useState</span>(……);<br><span class="hljs-keyword">const</span> [queryData, setQueryDataData] = <span class="hljs-title function_">useRef</span>(……);<br><br><span class="hljs-keyword">const</span> handleChangePageSize = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setFormData</span>(formData)<br>  queryData.<span class="hljs-property">current</span> = 新的querYData<br>  <span class="hljs-title function_">getDataList</span>()<br>&#125;, []);<br><span class="hljs-keyword">const</span> getDataList = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-title function_">fetchData</span>(queryData.<span class="hljs-property">current</span>)<br>  &#125;,<br>  [],<br>)<br><br></code></pre></td></tr></table></figure><h2 id="实现父组件调用子组件的方法"><a href="#实现父组件调用子组件的方法" class="headerlink" title="实现父组件调用子组件的方法"></a>实现父组件调用子组件的方法</h2><h3 id="子组件是原生-DOM"><a href="#子组件是原生-DOM" class="headerlink" title="子组件是原生 DOM"></a>子组件是原生 DOM</h3><p>子组件是原生的 html 的 DOM 可以直接使用 ref 调用原生 DOM 上的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Father</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          ref.current?.focus();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        点击实现input Focus</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="子组件是自定义组件"><a href="#子组件是自定义组件" class="headerlink" title="子组件是自定义组件"></a>子组件是自定义组件</h3><p>对于自定义组件 React 默认是不允许组件访问其他组件的 DOM 节点，即使是父子组件也不可以，想使用子组件的方法，必须使用 forwardRef 将组件暴露出来。</p><h4 id="调用用自定义组件内原生-DOM-组件的方法"><a href="#调用用自定义组件内原生-DOM-组件的方法" class="headerlink" title="调用用自定义组件内原生 DOM 组件的方法"></a>调用用自定义组件内原生 DOM 组件的方法</h4><p>通过 forwardRef 选择接收传递的 inputRef,进而传递到 input 的 ref 上,这样就实现了对自定义组件内部原生组件的 DOM 获取</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Father</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          inputRef.current?.focus();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        点击实现input Focus</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Children</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref: Ref&lt;HTMLInputElement&gt;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="调用用自定义组件内自定义方法"><a href="#调用用自定义组件内自定义方法" class="headerlink" title="调用用自定义组件内自定义方法"></a>调用用自定义组件内自定义方法</h4><p>这个应该是最为常用的使用场景，通过 useImperativeHandle 暴露指定的方法,需要暴露什么方法只需要在指定的 useImperativeHandle 下暴露即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyRef</span> &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">IMyRef</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          ref.current?.sayHi();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        调用Children的handleTest方法</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Children</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref: Ref&lt;IMyRef&gt;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> handleTest = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>  &#125;, []);<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">sayHi</span>: handleTest,<br>  &#125;));<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="泛型组件内暴露子组件的方法给父组件"><a href="#泛型组件内暴露子组件的方法给父组件" class="headerlink" title="泛型组件内暴露子组件的方法给父组件"></a>泛型组件内暴露子组件的方法给父组件</h4><p>在封装高级组件时经常会遇到这种需求，组件需要接受泛型，forwardRef 也需要接受泛型，传递 ref 时类型经常会犯错，这里我采用迂回的方法，不直接传递 ref，使用变量 myRef 做 props 的一个值，给 myRef 定义类型骗过 useImperativeHandle，避免使用 forwardRef 也可以实现，实现如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyRef</span> &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">JsErr</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">IMyRef</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          ref.current?.sayHi();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        调用Children的handleTest方法</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">myRef</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Children</span> = (<span class="hljs-params">&#123; myRef &#125;: &#123; myRef: Ref&lt;IMyRef&gt; &#125;</span>) =&gt; &#123;<br>  <span class="hljs-comment">// myRef并不是ref传递的，是通过props传递的，这样就避免使用forwardRef了</span><br>  <span class="hljs-keyword">const</span> handleTest = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>  &#125;, []);<br>  <span class="hljs-title function_">useImperativeHandle</span>(myRef, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">sayHi</span>: handleTest,<br>  &#125;));<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js闭包</title>
    <link href="/2022/08/03/closure/"/>
    <url>/2022/08/03/closure/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>本文是从内存管理的角度来理解闭包的，因此会有一些前置知识需要建立</p><h3 id="js-运行原理"><a href="#js-运行原理" class="headerlink" title="js 运行原理"></a>js 运行原理</h3><p>js 是一门解释执行语言，因此在执行前会进行解释，解释完成后才会执行，注意它并不是等所有的代码都解释完后才执行的，而是边解释边执行的。</p><ul><li>对于下文代码，js 先只会解释 foo 函数和 fn 变量，然后执行 foo 函数，执行 foo 函数过程中遇到 bar 函数，再解释 bar 函数，进而执行，并不是把 foo bar fn 都解释完成后再执行代码<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;sunshine&quot;</span>;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bar;<br>&#125;<br><span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure></li><li>解释变量的过程，就是给变量赋值了一个 undefine 值，之后执行的时候才会进行真正的赋值操作</li><li>解释函数的过程，遇到函数，会在堆内存上创建内存空间，内存空间上存储两部分内容，第一个是函数的 parent_scope(父级作用域)，另一个是函数的执行代码。<font color="red">也就是说函数的父级作用域是在函数定义的时候指明，而不是函数调用的时候确定。</font> foo 函数定义的时候的作用域是全局，故打印的 foo 而不是 bar<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;bar&quot;</span>;<br>  <span class="hljs-title function_">foo</span>();<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// foo</span><br></code></pre></td></tr></table></figure></li><li>js 代码在具体执行的过程中，会运行在函数执行栈里，处于全局的变量和函数运行在全局执行上下文，每一个具体函数中运行的是函数执行上下文，每一个执行上下文由三部分构成，VO:变量对象，scope_chain:作用域链由自己的 VO 对象和父级作用域确定，以及执行时运行的执行代码(前两者解析函数时确定，后者执行时确定)。</li><li>js 查找变量是按照作用域链查找的</li></ul><h2 id="闭包运行分析"><a href="#闭包运行分析" class="headerlink" title="闭包运行分析"></a>闭包运行分析</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;cy&quot;</span>;<br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">24</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><p>上面的代码 name 和 function bar 就构成了一个闭包，具体的运行过程见下图<img src="/pic/closure/closure.png">.</p><ol><li><p>函数全局解析时，遇到 函数 foo 时会在堆上创建 foo 对象，对象存储了 foo 的父级作用域也就是全局作用域 GO(Global Object) 和代码体 <font color = "red">定义函数时确定父级作用域</font>，遇到 fn 的时候进行解析，在 GO 对象上添加属性 fn 值为 undefined</p></li><li><p>解析完毕执行代码，执行 foo 函数，执行函数会创建函数执行上下文，并将执行上下文入函数执行栈，函数执行栈里确定 VO(Variable Object)：也就是当前函数内部的变量对象，取名叫激活对象 AO(Active Object),开始解析函数内部变量，AO 解析时 name 和 age 都是 undefined,遇到 function bar 继续解析在堆上开辟内存空间地址是 0x20，确定父级作用域 foo 的 AO，和代码体。</p></li><li><p>执行 foo 内部代码进行赋值操作 foo AO 中的 name 和 age 变为“cy” 和 24,返回 bar 函数给全局里的 fn，实际返回的是函数在堆上的地址，故而 GO 中的 fn 就变成了 0x20,foo 函数执行完毕，出栈，foo 的执行上下文销毁。<font color = "red">这时候 foo 的 AO 并没有销毁,因为解析函数时 bar 的 parent_scope 引用这 foo 的 AO</font>。</p></li><li><p>继续执行 fn()，创建函数执行上下文，AO 是 bar 自己的包括传递的实参和自己内部的变量，scope_chain 是 bar 的 AO+parent_scope:foo 的 AO 。解析完毕开始执行代码 <code>console.log(name)</code> name 变量沿着作用域链查找，bar 的 AO 上没有，就往上查找在 foo 的 AO 上查找，继续往上找，找到 GO 没有就会报错，这里找到 foo 的 AO 上就找到了就直接打印出来了。函数执行完毕函数出栈。</p></li><li><p>这里 bar 函数和外层的 name 就构成了闭包。</p></li></ol><p>也就是说：js 中的函数如果访问了外层作用于的变量，那它们就构成了一个闭包。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>闭包往往很容易引起内存泄漏，继续以上文的例子为例，上面的代码执行完毕后，GO 中的 fn 持续引用这 bar 函数，bar 持续引用这 foo 的 AO，如果 js 中类似这样的引用很多，垃圾回收不能回收，就会造成内存泄漏的问题，因此为了解决这个问题，<font color = "red">对于不使用的函数，将其引用赋值为 null</font>，这样 bar 的引用消失，bar 就会在下次垃圾回收时销毁，接着 foo 的 AO 也就销毁了。</p><p>注意： 上文例子中 V8 对闭包也有优化，foo 中 AO 的 name 保留了，age 由于没有被使用，V8 将其销毁了以节约性能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js高级系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript高级类型</title>
    <link href="/2022/08/02/ts-learning/"/>
    <url>/2022/08/02/ts-learning/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><p><code>Record&lt;K,V&gt;</code> 创建一个以 K 为属性的类型，以 V 为值类型的对象。</p><ul><li>使用 Record 快速创建具有约束性质的对象类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ISubject</span> = <span class="hljs-string">&quot;Math&quot;</span> | <span class="hljs-string">&quot;Chinese&quot;</span> | <span class="hljs-string">&quot;English&quot;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IGrade</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">ISubject</span>, <span class="hljs-built_in">number</span>&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">myGrade</span>: <span class="hljs-title class_">IGrade</span> = &#123;<br>  <span class="hljs-title class_">Math</span>: <span class="hljs-number">99</span>,<br>  <span class="hljs-title class_">Chinese</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-title class_">English</span>: <span class="hljs-number">99</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h2><p><code>Partial&lt;T&gt;</code> T 是一个对象类型，这是取 T 这个对象的部分键值对作为属性，原理如下：</p><ul><li>keyof 是取对象类型的所有的属性 in 是取其中属性之一</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IPartial</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">mathGrade</span>: <span class="hljs-title class_">IPartial</span>&lt;<span class="hljs-title class_">IGrade</span>&gt; = &#123;<br>  <span class="hljs-title class_">Math</span>: <span class="hljs-number">100</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Record 结合 Partial 实现 AB 对象合并,A 对象如果有 B 对象的值就替换 B 对象</li><li>A 对象是 B 对象的一部分故而就是 Partial 实现，T 也需要泛型约束</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IMerge</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  sourceObj: Partial&lt;T&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  targetObj: T</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> T;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ITargetObj</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hhhh&quot;</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">999</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">merge</span>: <span class="hljs-title class_">IMerge</span>&lt;<span class="hljs-title class_">ITargetObj</span>&gt; = <span class="hljs-function">(<span class="hljs-params">sourceObj, targetObj</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> targetObj) &#123;<br>    <span class="hljs-keyword">const</span> itemVal = sourceObj[key];<br>    itemVal &amp;&amp; (targetObj[key] = itemVal);<br>  &#125;<br>  <span class="hljs-keyword">return</span> targetObj;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h2><p>extends 的使用</p><ul><li>如果在泛型<code>&lt;&gt;</code>中使用就是表示泛型约束 比如<code> &lt;T extends Record&lt;string,any&gt;&gt;</code>表示的是传入的泛型 T 必须是属性是字符串，值任意类型的对象</li><li>如果 extends 紧跟泛型后面就表示条件类型,T 继承 U 那么结果就是 X 类型，否则就是 Y 类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test</span>&lt;T, U, V&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; ? U : V;<br></code></pre></td></tr></table></figure><h2 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h2><p>infer 表示在 extends 条件语句中待推断的类型变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ParamType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (<span class="hljs-attr">arg</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : T;<br></code></pre></td></tr></table></figure><ul><li>在这个条件语句 T extends (arg: infer P) &#x3D;&gt; any ? P : T 中，infer P 表示待推断的函数参数。 整句表示为：如果 T 能赋值给 (arg: infer P) &#x3D;&gt; any，则结果是 (arg: infer P) &#x3D;&gt; any 类型中的参数 P，否则返回为 T。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Func</span> = <span class="hljs-function">(<span class="hljs-params">user: User</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Param</span> = <span class="hljs-title class_">ParamType</span>&lt;<span class="hljs-title class_">Func</span>&gt;; <span class="hljs-comment">// Param = User</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">AA</span> = <span class="hljs-title class_">ParamType</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p><code>ReturnType&lt;T&gt;</code> 表示函数返回值的类型，实现原理如下</p><ul><li>T 如果是这个函数，则把函数返回值的类型导出即可，这里使用到了 infer，infer 是等待推断的类型，这里需要推断的类型是返回值的类型，就是把 infer 的值当做一个变量来使用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span><br>) =&gt; infer R<br>  ? R<br>  : <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端debug</title>
    <link href="/2022/08/01/debug/"/>
    <url>/2022/08/01/debug/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>本文仅整体一些本人之前不曾了解过的 chrome 调试技巧</p><h2 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h2><ol><li>调试样式：先选中对应调试的元素</li><li>样式区选中.cls 动态选中需要选择的类<img src="/pic/debug/1.png"></li><li>选中:hover 区域，只调试伪类选择器对应的 css 效果<img src="/pic/debug/2.png"></li><li>选中 computed 计算区的 filter 进行快速筛选某个属性，筛选到对应的属性后选中旁边的小箭头可以快速跳转到 styles 区域下的类下面的样式<br><img src="/pic/debug/3.png"></li></ol><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><ol><li>不同类型的值，日志颜色不同，数值是紫色，字符串是青色</li><li><code>console.table()</code> 打印数组和对象以表格方式展开便于观察</li><li><code>console.dir()</code> 展开文件树结构，适合打印 DOM 节点上具有的属性</li><li><code>console.error() console.warning()</code>较为显眼的日志打印技巧</li><li>添加占位符实现某种样式打印控制台的结果<img src="/pic/debug/4.png"></li></ol><h2 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h2><ol><li>代码里直接写<code>debugger</code> 或者直接在 sources 面板下的 js 中选中具体的行，进行打断点，刷新浏览器进行 debugger.</li><li>右侧的 watch 直接监视需要查看的变量</li><li>BreakPoints 有多个断点时可以快捷取消选中断点</li><li>Scope：作用域：可以观察函数执行作用域和闭包</li><li>callStack：函数执行栈</li><li>XHR&#x2F;fetch BreakPoints 区域添加指定请求的 url,当请求发生的时候会触发断点<img src="/pic/debug/5.png"></li><li>线上代码调试技巧，打包的时候 webpack 开启 sourcemap，这样会生成 sourcemap，部署的时候只部署源代码，sourcesmap 文件存放到监控系统，这样线上报错的时候，监控系统会根据 sourcemap 指明源代码具体报错的代码行位置。<ul><li>也可以使用代理工具进行简单使用 sourcemap，代理工具将访问线上的 sourcemap 代理到本地的 sourcemap 上也可以进行线上调试。</li></ul></li></ol><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><ol><li>waterfall 区域可以观察请求是否是串行还是并行执行,第一个标记区域发现对齐的，所以是并行请求，第二个选中区域是错开的，故而是串行请求<br><img src="/pic/debug/6.png"></li></ol><h2 id="Performance-、LightHouse"><a href="#Performance-、LightHouse" class="headerlink" title="Performance 、LightHouse"></a>Performance 、LightHouse</h2><ol><li><p><a href="https://googlechrome.github.io/devtools-samples/jank/">chrome 提供的性能调试例子</a>，在 performance 区域进行录制分析。</p></li><li><p>以页面出现卡顿为例，录制后打开 Frames 下滑动鼠标滚轮明显发现掉帧现象，选中 Main 展开滑动滚轮放大后发现有红色区域，点击红色区域下面的 Summary 区域的 Callstacks 下会指出可能出现性能问题的文件，点击进行查看分析即可。</p><p><img src="/pic/debug/7.png">.<br><img src="/pic/debug/8.png"><br><img src="/pic/debug/9.png"><img src="/pic/debug/10.png"><br><img src="/pic/debug/11.png"></p></li><li><p>LightHouse 是 performance 的“简洁版”，用可以量化的分数来评判网站的性能</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>debug</tag>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器工作原理</title>
    <link href="/2022/07/30/browser/"/>
    <url>/2022/07/30/browser/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="浏览器输入-URL-的基本过程"><a href="#浏览器输入-URL-的基本过程" class="headerlink" title="浏览器输入 URL 的基本过程"></a>浏览器输入 URL 的基本过程</h2><p>传统的 SSR：用户在浏览器输入 url，经过 DNS 服务器解析为 ip 地址，向服务器发送 GET 请求，服务器最终返回 index.html 这个文件给客户端也就是浏览器<br>工作原理见下图</p><p><img src="/pic/browser/dns.png"></p><h2 id="浏览器解析-HTML-的过程"><a href="#浏览器解析-HTML-的过程" class="headerlink" title="浏览器解析 HTML 的过程"></a>浏览器解析 HTML 的过程</h2><p>浏览器并不是获得 index.html 就立即下载了对应的 css 文件<code>&lt;link href&gt;&lt;/link&gt;</code>，js 文件<code>&lt;script src&gt;&lt;script&gt;</code>，而是随着 index.html 的一行一行的执行遇到了对应的 link 标签和 script 标签才开始向服务器下载这些资源。css 和图片视频等都属于静态资源。浏览器的引擎分为两部分，一部分是渲染引擎，一部分是 js 引擎，渲染引擎待 css 和 html 整合成渲染树以后，将此渲染到页面上。js 引擎负责处理的就是将 js 代码转为机器码在 CPU 中最后执行的过程。解析过程见下图</p><p><img src="/pic/browser/render.png"></p><h2 id="js-引擎解析-js-过程"><a href="#js-引擎解析-js-过程" class="headerlink" title="js 引擎解析 js 过程"></a>js 引擎解析 js 过程</h2><p>常用的 js 引擎就是 chrome 的 v8 内核，这里以 v8 内核指代。</p><p><img src="/pic/browser/js-execu.png"><br>v8 内核先对 js 文件进行预解析，生成 GO 对象(GlobalObject)，存放 js 内置的对象比如说 String Date 以及 js 文件中初始化的变量，比如说<code>var name = &quot;hhhh&quot;</code>中的 name 变量等（注意这时候 js 还并没有执行，因此还没有进行赋值操作，故而此时 name 的值为 undefined—这就是变量提升的来源）。生成全局的 GO 之后将 js 文件的代码转为 AST（抽象语法树）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Vue 中的 template 模板引擎也是转为 ast 的">[1]</span></a></sup>,为了跨平台的需求会将 AST 转化为字节码<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="mac linux windows 的 cpu 执行指令不同，即同一段程序的机器码不同，故而先转化为字节码再转为机器码来实现跨平台">[2]</span></a></sup>，再转为机器码，最终执行，但是 V8 引擎为了做到高效的执行，在预解析形成 GO 全局对象的阶段时将所有存在的变量已经存储于 GO 中，在 AST 转化时进行词法分析，对于高频使用的函数，会进行直接转化为机器码，这样再以后执行的时候直接调用机器码执行，性能会大幅度提升。注意到有时候直接转为机器码之后反而又转为了字节码是因为以下原因：以前执行一直都是两个数相加，一直使用机器码没有问题，但是一旦输入两个字符串之后，这就会发生改变所以就有了 deoptimise 的过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Vue 中的 template 模板引擎也是转为 ast 的<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>mac linux windows 的 cpu 执行指令不同，即同一段程序的机器码不同，故而先转化为字节码再转为机器码来实现跨平台<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>js高级系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react admin权限设计</title>
    <link href="/2022/07/15/react-admin-design/"/>
    <url>/2022/07/15/react-admin-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>react admin 权限控制方案大体上有两种方案：前端控制路由表和后端控制路由表</p><h2 id="前端控制路由"><a href="#前端控制路由" class="headerlink" title="前端控制路由"></a>前端控制路由</h2><p>前文<a href="https://sunburst89757.github.io/my-blogs/blog/react-login-design">react-ts-admin 路由权限设计方案</a>的权限是由前端控制的路由表，根据后端给予当前用户的角色，在前端生成对应路由表来实现权限管理（权限管理方案基于<a href="https://github.com/PanJiaChen/vue-element-admin">vue-element-admin</a>的权限管理方案），但是此种方案缺点明显</p><ul><li>每个用户对应的角色生成的路由表由前端固定，一旦后期新增角色，需要重新部署前端应用。</li><li>用户对应角色的映射路由表的生成方式不够灵活。</li><li>此种方案需要前端手动注册所有的路由，router 书写繁杂</li></ul><h2 id="后端控制路由"><a href="#后端控制路由" class="headerlink" title="后端控制路由"></a>后端控制路由</h2><h3 id="前端动态注册路由"><a href="#前端动态注册路由" class="headerlink" title="前端动态注册路由"></a>前端动态注册路由</h3><ol><li><p>后端根据用户直接返回当前用户的可访问路由 accessRoutes(后端可以根据角色映射),前端根据返回的路由动态生成对应的组件。如此，当用户访问当前用户不允许访问的路由，由于前端根本没有注册这种路由，因此直接就会匹配到*,重定向 404，因此实现页面权限管理。</p></li><li><p>实现时需要考虑几个问题</p><ul><li>系统在后端获取可访问的路由时，需要注册几个基本的路由，比如 &#x2F;login 等页面</li><li>动态生成路由组件，必须使系统重新渲染，故而路由组件必须存储在 store 内（本文使用 redux）</li><li><font color="red">刷新带来的问题</font></li><li>一旦在用户的权限页面（后端返回的可访问页面）刷新必然会导致 store 里维护的路由组件置空，刷新后的页面重新访问改页面，路由组件没有注册必然系统崩溃。<ul><li>思路一：在路由拦截组件内部，根据某个状态条件判断，重新获取 accessRoutes，但是此方法只适用于 vue-router，因为 vue-router 的拦截器是全局的，不需要确定当前路由是否注册就进入路由拦截；但是 react router 的拦截组件是在当前路由注册的条件下进行拦截，因此路由不注册，不可能进行拦截组件内部重新获取可访问路由，因此此方案不可行。</li><li>思路二：由于 react-router 拦截组件是在路由注册时才能够实现拦截，故可以于登录后生成 accessRoutes，并存储于缓存里，刷新后从缓存里读取 accessRoutes 注册路由来实现访问，但是从缓存读取的 accessRoutes 经 useRoutes 注册<font color = "red">提示失败，原因未知,后续研究</font></li></ul></li></ul></li><li><p>实现细节—根据思路二实现</p><ul><li><p>路由配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//  路由配置 ---类似如下</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyLayout</span>&gt;</span></span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;布局&quot;</span>,<br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;dashboard&quot;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LazyLoad</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/Dashboard&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LazyLoad</span>&gt;</span></span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;首页&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>];<br><span class="hljs-comment">//  生成react router dom 6需要的结构</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateRouterForReactRouter</span> = (<span class="hljs-params">routes: RouteObject[]</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (route.<span class="hljs-property">children</span>) &#123;<br>      route.<span class="hljs-property">children</span> = <span class="hljs-title function_">generateRouterForReactRouter</span>(route.<span class="hljs-property">children</span>);<br>    &#125;<br>    <span class="hljs-comment">// 路由拦截器 登录和授权页面不需要鉴权</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInterceptRoute</span>(route)) &#123;<br>      route.<span class="hljs-property">element</span> = (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterBeforeEach</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;route.meta.title&#125;</span>&gt;</span></span><br><span class="language-xml">          &#123;route.element&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">RouterBeforeEach</span>&gt;</span></span><br>      );<br>    &#125;<br>    <span class="hljs-keyword">return</span> route;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>登录后获取后端生成路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">run</span>: handleLogin &#125; = <span class="hljs-title function_">useRequest</span>(<br>  <span class="hljs-function">(<span class="hljs-params">params: userType</span>) =&gt;</span> <span class="hljs-title function_">login</span>(params),<br>  &#123;<br>    <span class="hljs-attr">manual</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">onSuccess</span>: <span class="hljs-keyword">async</span> (res) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">success</span>) &#123;<br>        cache.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;token&quot;</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);<br>        <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: userRoutes &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserRoutes</span>();<br>        <span class="hljs-keyword">const</span> accessRoutes =<br>          <span class="hljs-title function_">generateAccessRoutesForReactRouter</span>(userRoutes);<br>        cache.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>, accessRoutes);<br>        <span class="hljs-title function_">dispatch</span>(gener);<br>        <span class="hljs-title function_">navigate</span>(<span class="hljs-string">&quot;/dashboard&quot;</span>);<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error, <span class="hljs-string">&quot;错误信息&quot;</span>);<br>    &#125;,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure></li><li><p>注册路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyRoutes</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">myRouter</span>: <span class="hljs-title class_">RouteObject</span>[] = [];<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<br>    <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span><br>  );<br>  <span class="hljs-comment">// 已经成功登录后 路由从store里读取</span><br>  <span class="hljs-keyword">if</span> (accessRoutes.<span class="hljs-property">length</span> &gt; <span class="hljs-number">2</span>) &#123;<br>    myRouter = accessRoutes;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 刷新后 accessRoutes会重置，路由就从缓存里读取，刷新路由重新进入刷新前的路由，在拦截器里重新获取accessRoutes</span><br>    myRouter = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> routes = <span class="hljs-title function_">useRoutes</span>(myRouter);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">100vh</span>&quot; &#125;&#125;&gt;</span>&#123;routes&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>路由拦截器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouterBeforeEach</span> = (<span class="hljs-params">&#123; children, title &#125;: interceptOBj</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span>);<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <span class="hljs-comment">// 验证是否登录（刷新）</span><br>  <span class="hljs-keyword">const</span> authLogin = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//获取用户的角色 菜单路由 权限信息</span><br>      <span class="hljs-keyword">if</span> (accessRoutes.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-comment">//   刷新导致store数据丢失，重新获取</span><br>        <span class="hljs-title function_">getUserRoutes</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span>  accessRoutes = <span class="hljs-title function_">generateAccessRoutesForReactRouter</span>(res.<span class="hljs-property">data</span>);<br>      &#125;<br>    &#125;)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;, []);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;authLogin?children:<span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>前文<a href="https://sunburst89757.github.io/my-blogs/blog/react-login-design#%E4%B8%80react-router-%E4%B8%8E-vue-router-%E7%9A%84%E5%8C%BA%E5%88%AB">react-ts-admin 路由权限设计方案</a>已详细说明，这里不再赘述。</p><h3 id="前端注册全部路由"><a href="#前端注册全部路由" class="headerlink" title="前端注册全部路由"></a>前端注册全部路由</h3><ol><li><p>由于前面方案刷新后缓存读取的 routes 配置不能够在 useRoutes 里生效，因此选择了前端手动注册全部路由，根据后端返回的路由生成一个可访问的路由进行鉴权来生成 404。</p></li><li><p>实现时考虑的问题</p><ul><li><p>前端手动注册全部路由，因此需要在路由拦截组件里除了需要判断是否登录，也需要进行逻辑校验是否有权限，无权限进入 404 的判断。</p></li><li><p>逻辑校验权限需要后端发送可访问的路由，这个请求存放的位置需要思考</p><ul><li>思路一：登录的时候直接发送这个请求，将获取的 accessRoutes 由 store 维护，避免刷新时造成 store 丢失存于缓存，但是刷新后 store 丢失的数据还需要及时获取,思路是直接存放于拦截器里再一次请求恢复 store，但是 authRoute 维护就从缓存里读取，避免计算过慢直接返回 404 了。</li><li>思路二：将请求直接存放于 layout 组件，layout 不需要鉴权，并且刷新的每一个页面都是 layout 作为一级组件，就避免了 login 和拦截组件的两次请求冗余，并且也不会让登陆页面请求过多造成页面渲染阻塞</li></ul></li></ul></li><li><p>实现细节</p><ul><li><p>注册路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; myRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./config&quot;</span>;<br><br><span class="hljs-comment">// 注册所有路由</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyRoutes</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> routes = <span class="hljs-title function_">useRoutes</span>(myRouter);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">100vh</span>&quot; &#125;&#125;&gt;</span>&#123;routes&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>layout 获取可访问路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyLayout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useAppDispatch</span>();<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<br>    <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span><br>  );<br>  <span class="hljs-comment">// 首次渲染执行  刷新时重新获取</span><br>  <span class="hljs-title function_">useAsyncEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (accessRoutes.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: menuRoutes &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserMenuList</span>();<br>      <span class="hljs-keyword">const</span> realMenuRoutes = <span class="hljs-title function_">generateAccessRoutes</span>(menuRoutes);<br>      <span class="hljs-keyword">const</span> siderRoutes = <span class="hljs-title function_">generateRouterForBackEnd</span>(menuRoutes);<br>      cache.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>, realMenuRoutes);<br>      <span class="hljs-comment">// 生成菜单路由</span><br>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addRoutes</span>(siderRoutes));<br>      <span class="hljs-comment">// 生成可以访问的路由结构</span><br>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">updateAccessRoutes</span>(realMenuRoutes));<br>    &#125;<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">100vh</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">MyHeader</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggle&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyHeader</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">MySider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MySider</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">MyContent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyContent</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>拦截器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouterBeforeEach</span> = (<span class="hljs-params">&#123; children, title &#125;: interceptOBj</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<br>    <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span><br>  );<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <span class="hljs-comment">// 验证是否登录</span><br>  <span class="hljs-keyword">const</span> authLogin = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;, []);<br>  <span class="hljs-keyword">const</span> authRoute = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> accessRoutes.<span class="hljs-title function_">includes</span>(location.<span class="hljs-property">pathname</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>).<span class="hljs-title function_">includes</span>(location.<span class="hljs-property">pathname</span>);<br>  &#125;, [location.<span class="hljs-property">pathname</span>, accessRoutes]);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;authLogin ? (</span><br><span class="language-xml">        authRoute ? (</span><br><span class="language-xml">          children</span><br><span class="language-xml">        ) : (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">        )</span><br><span class="language-xml">      ) : (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>react-router6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串操作方法总结</title>
    <link href="/2022/07/05/stringMethod/"/>
    <url>/2022/07/05/stringMethod/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>只有引用对象类型才具有属性和方法，string 作为原始值是不会拥有对应的属性和方法的，但是使用<code>&quot;abc&quot;.indexof(&quot;a&quot;)</code>是可以正常执行的。这是什么原因呢？</p><ol><li><p>js 给 string 做了原始封装类型 String（大写）,在使用<code>let str = &quot;abc&quot;;str.indexof(&quot;a&quot;)</code>的过程中执行了以下几个步骤</p><ul><li><code>let str = new String(&quot;abc&quot;) </code> 创建了 String 类型的实例</li><li>实例调用对应的方法和属性 <code>str.indexof(&quot;a&quot;)</code></li><li>销毁这个实例 <code>str = null</code></li></ul></li><li><p>声明字符串可以使用字面量声明也可以使用构造函数声明，但建议使用声明字符串的形式声明，避免类型上造成混乱理解不清。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC&quot;</span>; <span class="hljs-comment">// 推荐写法</span><br><span class="hljs-keyword">const</span> str1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// 不推荐</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// false</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span><br><span class="hljs-keyword">typeof</span> str; <span class="hljs-comment">// string</span><br><span class="hljs-keyword">typeof</span> str1; <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure></li><li><p>数值型和布尔型也有对应类似的 Number 和 Boolean 原始类型，使用上和注意事项与 String 相同。</p></li></ol><h2 id="String-常用操作方法"><a href="#String-常用操作方法" class="headerlink" title="String 常用操作方法"></a>String 常用操作方法</h2><h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><p><code>substring(start,end)</code>和 <code>slice(start,end)</code> 方法,都是返回一个新的字符串，不修改原字符串，从起点开始，不包括终点。<font color = "red">推荐使用 substring</font></p><ul><li>当 end 为负数时<ul><li>对于 substring 来说视为 0，自动将两个参数按照大小顺序互换</li><li>对于 slice 来说负数视为字符串的长度+ 负数视为 end 然后按照大小顺序互换</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abcd&quot;</span>;<br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// ab</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//a</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt;str.substring(0,2) ab</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt;str.slice(2,1) =&gt;str.slice(1,2) b</span><br></code></pre></td></tr></table></figure><h3 id="字符串位置"><a href="#字符串位置" class="headerlink" title="字符串位置"></a>字符串位置</h3><p><code>indexof(char, start)</code> <code> lastIndexof(char,start)</code>第一个顺序从 start 查找 char 字符，找到就停止；第二个是末尾从头查找 char 字符，查到停止。</p><ul><li><p>查找字符串中所有对应的 char 字符:找到之后序号加一继续向下找即可</p></li><li><p><font color = "red">既能寻找一个字符”a”也能寻找类似”ab”这种</font></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchAllChar</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, target: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span> = str.<span class="hljs-title function_">indexOf</span>(target, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">while</span> (position &gt;= <span class="hljs-number">0</span>) &#123;<br>    arr.<span class="hljs-title function_">push</span>(position);<br>    position = str.<span class="hljs-title function_">indexOf</span>(target, position + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="字符串包含"><a href="#字符串包含" class="headerlink" title="字符串包含"></a>字符串包含</h3><p><code>includes(str,start)</code> 从 start 开始搜寻，匹配到 str 就返回 true</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;foobarbaz&quot;</span>;<br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// true</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="字符串母大小写"><a href="#字符串母大小写" class="headerlink" title="字符串母大小写"></a>字符串母大小写</h3><p><code>toLowerCase()</code> 全部替换小写 <code>toUpperCase()</code> 全部替换大写</p><h3 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h3><p><code>trim()</code>去除字符串前后空格，不改变原字符串</p><h3 id="字符串转数组方法"><a href="#字符串转数组方法" class="headerlink" title="字符串转数组方法"></a>字符串转数组方法</h3><ol><li><p>利用字符串解构实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...str]); <span class="hljs-comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>split()</code>方法，接收一个参数，以间隔的形式分割字符串形成数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str1</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;1.1.1&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)); <span class="hljs-comment">// [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h3><ol><li><code>match()</code> 接收一个参数：正则表达式，返回值同 RegExp 对象的<code>exec()</code>方法的返回值相同。</li><li><code>search()</code> 接收正则表达式，返回找到的第一个字符的位置。<ul><li>与<code>indexOf()</code> 的区别是 search 可以通过正则查询</li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;cat bat sat&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span> = text.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/at/</span>); <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>replace()</code> 方法替换字符串方法，接收两个参数。第二个参数是字符串，替换第一个参数的值。<ul><li>第一个是字符串，第二个字符串替换第一个字符串，只能替换一个。</li><li>第一个是正则，第二个字符串，当正则有全局匹配时才会替换用第二个字符串替换全局。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript高级程序设计读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/06/27/binarySearch/"/>
    <url>/2022/06/27/binarySearch/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>本文理解基于此<a href="https://labuladong.github.io/algo/1/10/">labuladong 算法小抄</a></p><h2 id="寻找指定目标"><a href="#寻找指定目标" class="headerlink" title="寻找指定目标"></a>寻找指定目标</h2><ol><li><p>场景：有序无重复数组寻找 target。</p></li><li><p>基本原理：寻找有序数列当中的中间值，与中间值作比较，不断收缩序列大小直至找到目标值</p><ul><li>选择闭区间[left,right]就要表明 right 是能够取到的值，所以 right 的初值是 nums.length - 1 不是 nums.length;</li><li>因为[]区间闭合，所以 left&lt;&#x3D;right，区间的右边 left 是可以取到的，所以有等号</li><li>middle 不取(left+right)&#x2F;2 是因为，数据的存储是有上限的，避免数值整型溢出。</li><li>如果目标值比中间值要大，显然 target 位于(middle,right],所以要更新 left，已经验证过 nums[middle] !&#x3D;&#x3D; target,因此 left 更新值比 middle 大一，right 的更新同理。</li><li><font color="red">退出循环的条件:left &#x3D; right + 1</font></li><li>当二分查找最终都查不出来的时候就返回-1</li></ul></li><li><p>代码实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTarget</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//   右边界取数组的最右侧边是[left,right] 闭区间，所有的点都可取到</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//   因为所有的点都可以取到所以可以取等号</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-comment">//    防止溢出边界</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">middle</span>: <span class="hljs-built_in">number</span> = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-keyword">return</span> middle;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="寻找左右边界"><a href="#寻找左右边界" class="headerlink" title="寻找左右边界"></a>寻找左右边界</h2><ol><li><p>场景： 有序数组，但内部数值序列有重复的情况。</p></li><li><p>基本原理：在二分查找的时候不断收缩左右边界，直至找到。</p><ul><li>大体遍历和上面的原理相同，只是在等于目标值的处理方式不同。<ul><li>寻找左边界，碰到了目标值不代表结束，应该收缩边界，找左边界，那么就要让上限不断的向左靠近 所以就对 right &#x3D; middle - 1,同样的找有边界，就是 left &#x3D; middle + 1 靠近右边界。</li></ul></li><li>左右边界显然对应的就是 left 和 right 对应的对象。</li><li><font color = "red">左边界的意义，比如说左边界是 2，就表明数组有 2 个数小于 target，通过二分的循环只能找到这一点，但是不能确定边界值是不是等于 target，所以需要出来要判断一下，除此之外需要判断一下是否存在遍历的时候溢出的情况</font><ul><li>寻找左边界，所以判断是 left 是否溢出，left 在遍历过程中一直加一，所以判断 left &#x3D; nums.length;</li><li>寻找右边界，所以判断是 right 是否溢出，right 在遍历过程中一直减一，所以判断 right &lt; 0;</li></ul></li></ul></li><li><p>代码实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLeftBorder</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">middle</span>: <span class="hljs-built_in">number</span> = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-comment">// 收缩边界，寻找左边界，那么有边界需要不停的向左边收缩靠近</span><br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 边界溢出 和 实际的边界值和目标值没找到，就返回-1</span><br>  <span class="hljs-keyword">if</span> (left &gt;= nums.<span class="hljs-property">length</span> || nums[left] !== target) &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getRightBorder</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">middle</span>: <span class="hljs-built_in">number</span> = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-comment">// 收缩边界，寻找右边界，那么左边界需要不停的向右边收缩靠近</span><br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] !== target) &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当目标值不存在与数组中时</p><ul><li>左边界搜索对应的是靠近目标值但比目标值大的那个数</li><li>右边界搜索对应的是靠近目标值但比目标值小的那个数</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-ts-admin路由权限设计方案</title>
    <link href="/2022/06/06/react-login-design/"/>
    <url>/2022/06/06/react-login-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="一、react-router-与-vue-router-的区别"><a href="#一、react-router-与-vue-router-的区别" class="headerlink" title="一、react-router 与 vue-router 的区别"></a>一、react-router 与 vue-router 的区别</h2><ol><li>react-router 没有提高拦截器的 API 设计，因为为了权限拦截的功能，需要手动封装拦截组件，根据用户权限来决定是否渲染对应的路由组件。</li><li>vue-router 设计有动态添加路由的 api，因此可以在登录后通过角色权限的验证来动态添加权限路由，但是 react-router 并不存在动态添加路由的 api,因此必须 react 的路由组件必须在刚开始就全局注册好。根据指定的路由，在拦截组件里进行角色校验放行。</li><li>react-router 不存在类似 vue-router 对路由的配置方式，在 generateRouter 函数中将配置对象转化为 useRouts 接收的配置方式。</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateRouter</span> = (<span class="hljs-params">routes: RouteObject[]</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (route.<span class="hljs-property">children</span>) &#123;<br>      route.<span class="hljs-property">children</span> = <span class="hljs-title function_">generateRouter</span>(route.<span class="hljs-property">children</span>);<br>    &#125;<br>    <span class="hljs-comment">// 路由拦截器 登录和授权页面不需要鉴权</span><br>    <span class="hljs-keyword">if</span> (route.<span class="hljs-property">path</span> !== <span class="hljs-string">&quot;/login&quot;</span> &amp;&amp; route.<span class="hljs-property">path</span> !== <span class="hljs-string">&quot;/404&quot;</span>) &#123;<br>      route.<span class="hljs-property">element</span> = (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterBeforeEach</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&#123;route.meta.role&#125;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;route.meta.title&#125;</span>&gt;</span></span><br><span class="language-xml">          &#123;route.element&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">RouterBeforeEach</span>&gt;</span></span><br>      );<br>    &#125;<br>    <span class="hljs-keyword">return</span> route;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二、登录设计要点"><a href="#二、登录设计要点" class="headerlink" title="二、登录设计要点"></a>二、登录设计要点</h2><ol><li>登录流程：<ol><li>表单验证通过后发起登录请求，</li><li>根据获取的 role 权限，</li><li>生成对应的侧面菜单路由。</li></ol></li><li>react 的路由组件得全部注册（前端控制路由的方式），角色访问与否，在拦截组件中进行拦截。</li><li>菜单的注册方式<ol><li>配置路由时单独对应设计 siderRoutes 这个配置项。</li><li>在 sider 组件中对路由进行两次配置<ol><li>根据角色权限生成可访问的侧边路由</li><li>生成的侧边路由配置生成满足 antd 生成菜单对应的路由结构。</li></ol></li></ol></li><li>拦截组件的设计：类比 Vue-admin 的设计理念，token 做一次登录校验，角色做一次路由放行校验。</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouterBeforeEach</span> = (<span class="hljs-params">&#123; children, role, title &#125;: interceptOBj</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">useAppSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>);<br>  <span class="hljs-comment">// 验证是否登录（刷新）</span><br>  <span class="hljs-keyword">const</span> authLogin = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">// &#125; else &#123;</span><br>      <span class="hljs-comment">//   if (!userInfo.role) &#123;</span><br>      <span class="hljs-comment">//     // 说明没有获取用户的角色，第一次登录需要获取用户信息</span><br>      <span class="hljs-comment">//     dispatch(getUserInfoAction());</span><br>      <span class="hljs-comment">//   &#125;</span><br>    &#125;<br>    <span class="hljs-comment">// 不用考虑刷新，因为role已经数据持久化了刷新不会丢失</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;, []);<br>  <span class="hljs-comment">// 验证权限路由</span><br>  <span class="hljs-keyword">const</span> authRoute = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">//  配置路由时不传递或者说用户的角色是超级管理员时直接放行</span><br>    <span class="hljs-keyword">if</span> (!role || userInfo.<span class="hljs-property">role</span> === <span class="hljs-string">&quot;super-admin&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> role.<span class="hljs-title function_">includes</span>(userInfo.<span class="hljs-property">role</span>);<br>  &#125;, [role, userInfo.<span class="hljs-property">role</span>]);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;authLogin ? (</span><br><span class="language-xml">        authRoute ? (</span><br><span class="language-xml">          children</span><br><span class="language-xml">        ) : (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">        )</span><br><span class="language-xml">      ) : (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三、tabs-的设计"><a href="#三、tabs-的设计" class="headerlink" title="三、tabs 的设计"></a>三、tabs 的设计</h2><ol><li><p>tab 的设计探索见<a href="https://sunburst89757.github.io/my-blogs/blog/vue-login-design">vue 设计 tabs 和菜单联动</a></p></li><li><p>总原则：监视路由的变化实现 tab 和 menu 的联动。由于进行了跨组件通信，且状态数量过多，使用 redux 管理。</p></li><li><p>菜单点击路由跳转，tab 监听路由变化，生成新的 tab 或者 tab 跳转。</p></li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> matchRoute = <span class="hljs-title function_">matchRoutes</span>(siderRoutes, location.<span class="hljs-property">pathname</span>)!;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">newTab</span>: tabObject = &#123;<br>    <span class="hljs-attr">key</span>: matchRoute[matchRoute.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">pathname</span>,<br>    <span class="hljs-attr">title</span>: matchRoute[matchRoute.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">route</span>.<span class="hljs-property">meta</span>!.<span class="hljs-property">title</span>,<br>  &#125;;<br>  <span class="hljs-comment">// 解决直接关闭页面后，重新打开页面，生成一个/路径 ----对应的tab</span><br>  <span class="hljs-keyword">if</span> (newTab.<span class="hljs-property">title</span> === <span class="hljs-string">&quot;布局&quot;</span>) &#123;<br>    <span class="hljs-comment">// 有redux的数据持久化，因此直接找到离开前激活的页面进行跳转即可</span><br>    <span class="hljs-title function_">navigate</span>(tabActive);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeTab</span>(newTab));<br>  &#125;<br>&#125;, [location.<span class="hljs-property">pathname</span>, dispatch, navigate]);<br></code></pre></td></tr></table></figure><ol start="3"><li>tab 本身的操作，只处理 tab 本身，对 tab 进行增删跳转由 redux 管理 tabActive，真正实现路由跳转由对 tabActive 的监视实现。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue登录权限设计</title>
    <link href="/2022/05/29/vue-login-design/"/>
    <url>/2022/05/29/vue-login-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="一、登录流程"><a href="#一、登录流程" class="headerlink" title="一、登录流程"></a>一、登录流程</h2><ol><li><p>表单验证：验证账号和密码是否符合验证规则，验证通过后发起登录请求</p></li><li><p>这个登录只用于获取 token 注意：这里 token 必须存在缓存里—否则后面的刷新获取动态路由就失效了。</p></li><li><p>成功获取 token 后进行路由跳转</p></li><li><p>路由跳转执行路由守卫进行拦截</p><ol><li><p>不是去登录的路由，验证是否有 token，没有 token 就去登录</p></li><li><p>有 token 的情况</p><ol><li><p>在 pinia 下获取用户的角色，如果有角色，就直接放行</p></li><li><p>没有角色的情况 说明是第一次登录（或者是由于刷新导致的 role 丢失）。</p><ol><li><p>调取接口获取用户的详细信息：比如说用户名，id,role,图片，电话等信息。</p></li><li><p>根据用户的角色，映射生成可以访问的路由，进行动态路由注册，根据生成的可访问路由生成访问菜单。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">next</span>(&#123; ...to, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><h2 id="二、登录逻辑"><a href="#二、登录逻辑" class="headerlink" title="二、登录逻辑"></a>二、登录逻辑</h2><ol><li>原则：采取前端控制权限的方法，实现接口级权限，路由级权限，按钮级权限。</li><li>后端只需要发送用户 token 和对应的角色即可，前端根据写的路由中的 meta 信息生成当前角色可以访问</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue设计tabs和菜单联动</title>
    <link href="/2022/05/29/vue-tabs-design/"/>
    <url>/2022/05/29/vue-tabs-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="总的原则"><a href="#总的原则" class="headerlink" title="总的原则"></a>总的原则</h2><p>监听路由的变化实现 menu 与 tabs 的双向绑定。</p><h2 id="menu-的实现"><a href="#menu-的实现" class="headerlink" title="menu 的实现"></a>menu 的实现</h2><ol><li>menu 只需要点击能够实现跳转路由即可，这里跳转的方式，使用 click 还是直接用 el-menu 组件自身的 route 模式，取决于路由跳转是使用命名路由还是 path 直接跳，方便的程度与否取决于生成的菜单的结构。</li><li>该系统的实现基于点击菜单事件实现路由跳转，跳转的方式是命名路由跳转。</li></ol><h2 id="tabs-的引入的三个方案"><a href="#tabs-的引入的三个方案" class="headerlink" title="tabs 的引入的三个方案"></a>tabs 的引入的三个方案</h2><p>三个方案的不同点只在于点击菜单，如何生成 tab 的改进，tab 上的切换实现都是相同的。</p><h3 id="tab-的存储原则"><a href="#tab-的存储原则" class="headerlink" title="tab 的存储原则"></a>tab 的存储原则</h3><p>tabs 的所有数据存储在 tabStore 里，主要就是 tabs tabsActive menuActive acheComponents(keep-alive 缓存的组件 name)</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><ol><li>原则：点击菜单项将 tab 需要的信息构造成新的 tab 或者在原 tab 里进行切换。</li><li>实现：<ul><li>点击菜单将菜单项对应的 title 和 path（实际是命名路由）构造新的 tab 给 tabStore.tabs 里，并进行路由跳转。</li><li>表现形式上体现切换到指定的 tab，就将 tabActive 转为新的路由组件对应的名字上即可<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessageToTabs</span> = (<span class="hljs-params">menuOption: tabType, event: <span class="hljs-built_in">any</span></span>) =&gt; &#123;<br>  menuActive.<span class="hljs-property">value</span> = event.<span class="hljs-property">index</span>;<br>  tabOption.<span class="hljs-property">title</span> = menuOption.<span class="hljs-property">title</span>;<br>  tabOption.<span class="hljs-property">path</span> = menuOption.<span class="hljs-property">path</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;tabOption&quot;</span>, tabOption);<br>  tabsStore.<span class="hljs-title function_">addTab</span>(menuOption);<br>  router.<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-attr">name</span>: menuOption.<span class="hljs-property">path</span>,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li>缺点：将 menu 组件和 tabs 组件高度绑定了，点击 menu 需要传递给 tabs 组件相应信息。</li></ol><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><ol><li>原则：tab 下存储的组件表现形式实际只是不同路由切换的结果，因此可以考虑分离 tab 和 menu 的耦合关系，点击 menu 只进行路由跳转，可以在 layout 组件下只监听路由变化即可，路由变化来考虑是否新增 tab。</li><li>实现<ul><li>layout 组件下监听 route，route 发生变化，route.name 和 route.meta.name 存储有构造 tab 的信息</li></ul></li><li>缺点：<ul><li>layout 组件监听 route 实现了菜单情况下 spa 页面的 tab 增加，但是在退出登录时会也监听到了 login 这个路由也会新增到 tabs 内部，下次登录的时候就会出现登录这个选项卡就会出现在 tab 栏里。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">watch</span>(route, <span class="hljs-function">(<span class="hljs-params">newRoute</span>) =&gt;</span> &#123;<br>  tabsStore.<span class="hljs-title function_">handleTab</span>(newRoute);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><ol><li>原则： 选择将路由变化放在路由拦截器里处理.</li><li>实现：路由拦截分为了以下几种情况，只需要在后两种情况下操纵 tab 即可，特殊情况如刷新，404 页面，route 都会匹配两次，也会操作 tab，这两种情况下第一次匹配都会出现 route.name 都是 undefined，再单独给 404 路由不设置 name，就可以实现只有 spa 与 tab 相关。</li></ol><ul><li>去登录页面</li><li>第一次来到首页（刷新页面）</li><li>正常的切换到不同的页面</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs ts">&lt;!-- 拦截器 --&gt;<br>  router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getCache</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> !== <span class="hljs-string">&quot;/login&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/login&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;查询to对象&quot;</span>, to);<br><br>      <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>();<br>      <span class="hljs-comment">// 登录或者刷新的时候</span><br>      <span class="hljs-keyword">if</span> (!userStore.<span class="hljs-property">role</span>) &#123;<br>        <span class="hljs-keyword">await</span> userStore.<span class="hljs-title function_">getUserRole</span>();<br>        <span class="hljs-title function_">generateAccessRoutes</span>(userStore.<span class="hljs-property">role</span>, asyncRoutes);<br>        <span class="hljs-comment">// 注册动态路由</span><br>        asyncRoutes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(element);<br>        &#125;);<br>        userStore.<span class="hljs-title function_">generateUserMenus</span>();<br>        <span class="hljs-comment">// 不使用 next() 是因为，在执行完 router.addRoute 后，</span><br>        <span class="hljs-comment">// 原本的路由表内还没有添加进去的路由，会 No match</span><br>        <span class="hljs-comment">// replace 使路由从新进入一遍，进行匹配即可</span><br>        <span class="hljs-title function_">next</span>(&#123; ...to, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">next</span>();<br>      &#125;<br>      <span class="hljs-title function_">generateMenuAndTab</span>(to);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">next</span>();<br>  &#125;<br>&#125;);<br>&lt;!-- handleTab --&gt;<br><span class="hljs-title function_">handleTab</span>(<span class="hljs-params">route: RouteLocationNormalizedLoaded</span>) &#123;<br>  <span class="hljs-comment">// 刷新时，因为没有动态注册路由，所以匹配不到路由，对应的path和name就都是undefined，这不能添加到tab上</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;zhixinghandle&quot;</span>, route);<br><br>  <span class="hljs-keyword">if</span> (!route.<span class="hljs-property">name</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isTabInTabs</span>(route.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">RouteRecordName</span>)) &#123;<br>    <span class="hljs-keyword">const</span> tab = &#123;<br>      <span class="hljs-attr">title</span>: route.<span class="hljs-property">meta</span>.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>,<br>      <span class="hljs-attr">path</span>: route.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">RouteRecordName</span><br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addTab</span>(tab);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 已有的tab，重置tab状态</span><br>    <span class="hljs-comment">// console.log(route.name, &quot;名字&quot;);</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tabActive</span> = <span class="hljs-title class_">String</span>(route.<span class="hljs-property">name</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">menuActive</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tabActive</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="tabs-的实现"><a href="#tabs-的实现" class="headerlink" title="tabs 的实现"></a>tabs 的实现</h2><ol><li><p>原则：真正菜单对应的路由组件并没有放在 el-tab-panel 下，watch 在通用布局组件 layout 下面监听 route，route 发生变化，说明 tab 会出现相应的变化操作。不同 tab 的页面应该处于缓存状态，所以应该用 keep-alive 缓存状态，但是在关闭 tab 的时候相应的也需要对不用的组件进行销毁，这里不采取 destroy 来销毁组件，采用对 router-view 使用 include 来选择包含的组件进行缓存，关闭 tab 就移出。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// layout.vue 在这个页面监听路由的变化</span><br>&lt;el-main <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;<br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-tabs&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">nav-tabs</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav-tabs</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123; Component &#125;&quot;</span> &gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span></span><br><span class="language-xml">           <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;cacheComponents&quot;</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;Component&quot;</span> /&gt;</span></span><br><span class="language-xml">           <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>     &lt;/el-main&gt;<br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();<br><span class="hljs-keyword">const</span> tabsStore = <span class="hljs-title function_">useTabStore</span>();<br><span class="hljs-keyword">const</span> &#123; cacheComponents &#125; = <span class="hljs-title function_">storeToRefs</span>(tabsStore);<br></code></pre></td></tr></table></figure></li><li><p>操作 Tab:Tab 的数据全部存储在 store&#x2F;tabStore 下</p><ul><li>handleTab: 将路由拦截的路由对象 to 传递过来判断即可，判断是否是新增还是跳转即可。</li></ul></li><li><p>删除 tab</p><ol><li>删除后，选中的路由应该是上一个 tab 对应的路由路径</li><li>删除最后一个自动对应首页对应的路由</li></ol></li><li><p>点击 tab 实现路由的切换管理：直接点击的时候实现路由跳转即可，修改菜单的选中状态即可实现。</p></li></ol><p>**<em>这里还存在问题：</em><strong>路由组件存放在 el-tab-pannel 下会出现下面情况，有几个 tab 页面，选中其中一个 tab 页，它对应的组件 setup 会执行几次；具体来说有三个 tab 页 a,b,c，点击 a，</strong><em>a 页面的 setup 会执行三次，具体情况未知待测</em>**。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
