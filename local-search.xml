<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo fluid搭建教程</title>
    <link href="/2022/09/03/blog-build/"/>
    <url>/2022/09/03/blog-build/</url>
    
    <content type="html"><![CDATA[<p><a href="https://laosu.ml/2022/01/24/%E7%94%A8GitHub%20Actions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/?highlight=github+action">https://laosu.ml/2022/01/24/%E7%94%A8GitHub%20Actions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/?highlight=github+action</a></p><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/</a></p><p><a href="https://hexo.fluid-dev.com/posts/actions-deploy/">https://hexo.fluid-dev.com/posts/actions-deploy/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js面向对象--ES5的实现</title>
    <link href="/2022/08/29/prototype/"/>
    <url>/2022/08/29/prototype/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>es6 之前，js 实现面向对象的方法是借助构造函数实现的</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li>每一个对象都有自己的隐式原型对象 <code>[[prototype]]</code> ,浏览器环境和 node 都会提供一个 API <code>__proto__</code>属性让开发者访问到该对象上的原型对象,但是该 API 可能会存在一定的兼容性问题，本文都用 <code>__proto__</code>属性代替 <code>[[prototype]]</code></li><li>每一个函数都有自己的显示原型对象 <code>prototype</code>,这是 ECMAScript 实现的,不存在兼容性问题,<font color = "red">注意箭头函数没有 <code>prototype</code></font></li></ol><ul><li>函数的显示原型中存在一个属性<code>constructor</code>是一个函数指向它本身</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p><img src="/pic/prototype/1.png"></p><ol start="3"><li>函数也是一个对象，所以函数是既有显示原型对象也有隐式原型对象的。</li></ol><h3 id="new-构造函数发生了什么"><a href="#new-构造函数发生了什么" class="headerlink" title="new 构造函数发生了什么"></a>new 构造函数发生了什么</h3><ol><li>在 new 构造函数的时候内存中执行了以下事件</li></ol><ul><li>创建了一个空对象 <code>&#123;&#125;</code></li><li>将 this 绑定在这个空对象上</li><li>将函数的<code>prototype</code>属性赋值给这个对象的隐式原型 <code>__proto__</code>上</li><li>执行函数体中的代码</li><li>将 this 这个对象返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eating&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><p><img src="/pic/prototype/2.png"></p><ol start="2"><li>在用字面量声明一个对象的时候本质上是 <code>new Object()</code> 的一个语法糖，因此 Object 这个函数的 <code>prototype</code> 就给了 obj 这个对象的隐式原型 <code>__proto__</code><br>这里字面量的<code>__proto__</code>就是顶层原型了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// 对象的顶层原型</span><br></code></pre></td></tr></table></figure><p><img src="/pic/prototype/3.png"></p><h2 id="构造函数封装类"><a href="#构造函数封装类" class="headerlink" title="构造函数封装类"></a>构造函数封装类</h2><p>前文对于构造函数的封装，存在不妥之处，主要在于类中方法的实现,当用这个构造函数实现多个实例时可以发现，不同实例上的 eat 方法本应该没有区别，但是在这种方式下实现时，每一个实例的 eat 方法占用了不同的内存空间，也就是说实例化的时候开辟了多余的内存空间对内存造成了很大的浪费。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eating&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tyz&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">eat</span> === p1.<span class="hljs-property">eat</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>那么我们该如何优化呢？这时候我们就可以考虑借助到原型了，将方法挂载到每一个类的原型上，并不是直接挂载到对象的属性本身上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; eat&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tyz&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">eat</span> === p1.<span class="hljs-property">eat</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>为什么呢？方法（函数）在内存中实际上引用的是一个地址 Perosn 的原型对象上一个属性 eat 存储了一个方法，那么在 new 实例时将 prototype 这个对象的地址给了 p 这个对象的<strong>proto</strong>， 调用实际的方法是指向的同一个地址，因此就不会造成内存空间的浪费了。</p><p><img src="/pic/prototype/4.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>js高级系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios封装</title>
    <link href="/2022/08/06/axios/"/>
    <url>/2022/08/06/axios/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中，也被 Vue 官方推荐用于作请求库来使用，本文根据曾经项目里的实际需求和结合文章阅读做出的 axios 封装，以下是文件结构<br><img src="/pic/axios/file.png"><br>鉴于类具有更好的封装性质，所以使用 class 来封装。</p><h2 id="通用拦截器封装"><a href="#通用拦截器封装" class="headerlink" title="通用拦截器封装"></a>通用拦截器封装</h2><p>通用拦截器说明每一个实例化的请求都具有这个通用的拦截器，因此需要在 constructor 内部实现，实例化 axios 后直接挂载对应的拦截器。用于所有 http 请求都需要的通用拦截。</p><ul><li>用于登录失效后刷新登录：响应拦截器</li><li>用于实现全局请求的 load 效果：请求拦截、响应拦截</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRequest</span> &#123;<br>  <span class="hljs-attr">service</span>: <span class="hljs-title class_">AxiosInstance</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: AxiosRequestConfig</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span> = axios.<span class="hljs-title function_">create</span>(config);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(&quot;所有实例都请求拦截成功&quot;);</span><br>        <span class="hljs-keyword">return</span> config;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(err, &quot;所有实例都请求拦截失败&quot;);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">res: AxiosResponse</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(res, &quot;公共响应拦截成功&quot;);</span><br>        <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特殊拦截器封装"><a href="#特殊拦截器封装" class="headerlink" title="特殊拦截器封装"></a>特殊拦截器封装</h2><p>对于不同的服务器配置的 axios 可能需要有对应特殊的拦截需要在传入实例时进行配置，所以对传入的 config 进行扩展，支持传入特殊的请求拦截和响应拦截。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptors</span> &#123;<br>  requestSuccess?: <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> <span class="hljs-title class_">AxiosRequestConfig</span>;<br>  requestErr?: <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br>  responseSuccess?: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> = <span class="hljs-string">AxiosResponse</span>&gt;</span>(res: T) =&gt; T;</span><br><span class="language-xml">  responseErr?: (err: any) =&gt; any;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml"></span><br><span class="language-xml">interface RequestConfig extends AxiosRequestConfig &#123;</span><br><span class="language-xml">  interceptors?: Interceptors;</span><br><span class="language-xml">  successMsg?: string;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>同样的对于整个向服务器发送请求的拦截也是在实例化的瞬间就完成，故而也是封装在 constructor 内部的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRequest</span> &#123;<br>  <span class="hljs-attr">service</span>: <span class="hljs-title class_">AxiosInstance</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: RequestConfig</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span> = axios.<span class="hljs-title function_">create</span>(config);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(&quot;所有实例都请求拦截成功&quot;);</span><br>        <span class="hljs-keyword">return</span> config;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(err, &quot;所有实例都请求拦截失败&quot;);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>    <span class="hljs-comment">// 不同实例的请求拦截器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestSuccess</span>,<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestErr</span><br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">res: AxiosResponse</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    );<br>    <span class="hljs-comment">// 不同实例的响应拦截器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseSuccess</span>,<br>      config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseErr</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单个请求的拦截"><a href="#单个请求的拦截" class="headerlink" title="单个请求的拦截"></a>单个请求的拦截</h2><p>对于某些单个请求有时候需要做定制化的需求，比如说单独需要查看某个请求的进度条的使用情况，就需要对单个请求进行拦截。<br>单个请求的拦截就必须对 axios 的 request 请求进行拦截，需要单独封装实现方法。对于单个请求 axios 没有直接提供对应的拦截器 api 函数，需要自己实现。</p><ul><li>请求拦截本质上是在真正请求发生前对 config 做的操作，这里的方法本就是在请求发生前执行的操作，故而只需在 axios 的 request 方法执行前对 config 进行操作即可。</li><li>响应拦截：只需在获取响应后对其修改后再传递出去即可，这时需要借助 Promise,封装请求函数的时候返回 Promise，将修改好的 res 值在 resolve 出去即可实现响应拦截的效果。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts">request&lt;T = <span class="hljs-title class_">IMyResponse</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 这个return才是真正执行请求，在执行请求前进行请求拦截--目的就是改变config</span><br>    <span class="hljs-keyword">if</span> (config?.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestSuccess</span>) &#123;<br>      config = config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">requestSuccess</span>(config);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span><br>        .<span class="hljs-property">request</span>&lt;<span class="hljs-built_in">any</span>, T&gt;(config)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 响应成功的拦截</span><br>          <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseSuccess</span>) &#123;<br>            res = config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseSuccess</span>&lt;T&gt;(res);<br>          &#125;<br>          <span class="hljs-title function_">resolve</span>(res);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseErr</span>) &#123;<br>            err = config.<span class="hljs-property">interceptors</span>?.<span class="hljs-title function_">responseErr</span>(err);<br>          &#125;<br>          <span class="hljs-title function_">reject</span>(err);<br>        &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="axios-配置和导出"><a href="#axios-配置和导出" class="headerlink" title="axios 配置和导出"></a>axios 配置和导出</h2><p>建议配置文件和导出文件分离，有助于后续修改。</p><ul><li>配置文件提供 axios 通用配置比如 baseUrl timeout 等</li><li>导出文件暴露配置好的 axios 和通用的请求方法便于下一步单个请求函数的封装</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// config</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BASE_URL</span> = <span class="hljs-string">&quot;http://example.com&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span> = &#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-variable constant_">BASE_URL</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">interceptors</span>: &#123;<br>    <span class="hljs-attr">requestSuccess</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;特有的请求拦截成功&quot;</span>);<br>      <span class="hljs-keyword">return</span> config;<br>    &#125;,<br>    <span class="hljs-attr">requestErr</span>: <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err, <span class="hljs-string">&quot;特有的请求拦截失败&quot;</span>);<br>    &#125;,<br>    <span class="hljs-attr">responseSuccess</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;特有的响应拦截成功&quot;</span>, res);<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;,<br>    <span class="hljs-attr">responseErr</span>: <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;特有的响应拦截失败&quot;</span>, err);<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 完整的接口返回成功的话一般返回以下四个参数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyResponse</span>&lt;T = <span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>  <span class="hljs-attr">success</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImyRequest</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestConfig</span> &#123;<br>  <span class="hljs-comment">// RequestConfig里有data，这里再写一次是为了使用传入泛型的方法来约束data类型</span><br>  data?: T;<br>&#125;<br><span class="hljs-keyword">const</span> service = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRequest</span>(instanceConfig);<br><span class="hljs-comment">// 该请求方式默认为GET，且一直用data作为参数(条件解决了)；</span><br><span class="hljs-comment">// T是真正的请求函数发出的参数的类型</span><br><span class="hljs-comment">// V是请求返回体的data的类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> myRequest&lt;T, V = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">ImyRequest</span>&lt;T&gt;) &#123;<br>  <span class="hljs-keyword">const</span> &#123; method = <span class="hljs-string">&quot;GET&quot;</span> &#125; = config;<br>  <span class="hljs-keyword">if</span> (method === <span class="hljs-string">&quot;get&quot;</span> || method === <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>    config.<span class="hljs-property">params</span> = config.<span class="hljs-property">data</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> service.<span class="hljs-property">request</span>&lt;<span class="hljs-title class_">IMyResponse</span>&lt;V&gt;&gt;(config);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数级-api-封装"><a href="#函数级-api-封装" class="headerlink" title="函数级 api 封装"></a>函数级 api 封装</h2><p>对于 API 的封装建议使用单独的 API 文件夹管理，不同模块单独文件夹管理，每个页面单独 ts 文件管理，这样具体使用的时候直接引用对应的方法即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; myRequest &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../service&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">IUserInfo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/types&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> requestParams &#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Res</span> &#123;<br>  <span class="hljs-attr">token</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">nickName</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">params: requestParams</span>) &#123;<br>  <span class="hljs-keyword">return</span> myRequest&lt;requestParams, <span class="hljs-title class_">Res</span>&gt;(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/login/login&quot;</span>,<br>    params,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>    <span class="hljs-attr">successMsg</span>: <span class="hljs-string">&quot;登录成功&quot;</span>,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref在react中的使用</title>
    <link href="/2022/08/04/ref/"/>
    <url>/2022/08/04/ref/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="ref-的使用场景"><a href="#ref-的使用场景" class="headerlink" title="ref 的使用场景"></a>ref 的使用场景</h2><p>根据官方文档，ref 变量的值由 react 来维护，但是 ref 的值的变化并不会触发页面的重新渲染，因此 ref 的值实际上主要有两种使用场景。</p><ol><li>维护需要变化但是不影响页面渲染的值。</li><li>用于获取 DOM 实现父组件调用子组件的方法。</li></ol><h2 id="使用-ref-进行接口的查询"><a href="#使用-ref-进行接口的查询" class="headerlink" title="使用 ref 进行接口的查询"></a>使用 ref 进行接口的查询</h2><p>一个很常见的场景：查表业务中，更改了每页显示的数量后立刻调接口刷新页面数据,实现如下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_">useState</span>(……);<br><span class="hljs-keyword">const</span> handleChangePageSize = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setFormData</span>(formData)<br>  <span class="hljs-title function_">getDataList</span>()<br>&#125;, []);<br><span class="hljs-keyword">const</span> getDataList = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-title function_">fetchData</span>(formData)<br>  &#125;,<br>  [],<br>)<br><br></code></pre></td></tr></table></figure><p>实现的时候经常会出现页面数据仍然是上次的结果，查看 formData 确实是 set 过之后的结果，原因是 setData 引发的渲染 react 做的是批量更新的处理，是等所有的 state 都更新过后才会执行，所以 fetchData 拿到的数据是上一次渲染前的数据，因此页面的数据不会更新。</p><p>出现的问题是由于两次渲染前后 state 的变化导致的，那么我们就可以选择一个不影响渲染但是有 react 维护的值来存储查表业务即可实现，这时可以使用 ref 来保存查表需要的参数，state 用来维护页面的状态不参与查表的业务即可实现。实现如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_">useState</span>(……);<br><span class="hljs-keyword">const</span> [queryData, setQueryDataData] = <span class="hljs-title function_">useRef</span>(……);<br><br><span class="hljs-keyword">const</span> handleChangePageSize = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setFormData</span>(formData)<br>  queryData.<span class="hljs-property">current</span> = 新的querYData<br>  <span class="hljs-title function_">getDataList</span>()<br>&#125;, []);<br><span class="hljs-keyword">const</span> getDataList = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-title function_">fetchData</span>(queryData.<span class="hljs-property">current</span>)<br>  &#125;,<br>  [],<br>)<br><br></code></pre></td></tr></table></figure><h2 id="实现父组件调用子组件的方法"><a href="#实现父组件调用子组件的方法" class="headerlink" title="实现父组件调用子组件的方法"></a>实现父组件调用子组件的方法</h2><h3 id="子组件是原生-DOM"><a href="#子组件是原生-DOM" class="headerlink" title="子组件是原生 DOM"></a>子组件是原生 DOM</h3><p>子组件是原生的 html 的 DOM 可以直接使用 ref 调用原生 DOM 上的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Father</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          ref.current?.focus();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        点击实现input Focus</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="子组件是自定义组件"><a href="#子组件是自定义组件" class="headerlink" title="子组件是自定义组件"></a>子组件是自定义组件</h3><p>对于自定义组件 React 默认是不允许组件访问其他组件的 DOM 节点，即使是父子组件也不可以，想使用子组件的方法，必须使用 forwardRef 将组件暴露出来。</p><h4 id="调用用自定义组件内原生-DOM-组件的方法"><a href="#调用用自定义组件内原生-DOM-组件的方法" class="headerlink" title="调用用自定义组件内原生 DOM 组件的方法"></a>调用用自定义组件内原生 DOM 组件的方法</h4><p>通过 forwardRef 选择接收传递的 inputRef,进而传递到 input 的 ref 上,这样就实现了对自定义组件内部原生组件的 DOM 获取</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Father</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          inputRef.current?.focus();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        点击实现input Focus</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Children</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref: Ref&lt;HTMLInputElement&gt;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="调用用自定义组件内自定义方法"><a href="#调用用自定义组件内自定义方法" class="headerlink" title="调用用自定义组件内自定义方法"></a>调用用自定义组件内自定义方法</h4><p>这个应该是最为常用的使用场景，通过 useImperativeHandle 暴露指定的方法,需要暴露什么方法只需要在指定的 useImperativeHandle 下暴露即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyRef</span> &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">IMyRef</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          ref.current?.sayHi();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        调用Children的handleTest方法</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Children</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref: Ref&lt;IMyRef&gt;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> handleTest = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>  &#125;, []);<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">sayHi</span>: handleTest,<br>  &#125;));<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="泛型组件内暴露子组件的方法给父组件"><a href="#泛型组件内暴露子组件的方法给父组件" class="headerlink" title="泛型组件内暴露子组件的方法给父组件"></a>泛型组件内暴露子组件的方法给父组件</h4><p>在封装高级组件时经常会遇到这种需求，组件需要接受泛型，forwardRef 也需要接受泛型，传递 ref 时类型经常会犯错，这里我采用迂回的方法，不直接传递 ref，使用变量 myRef 做 props 的一个值，给 myRef 定义类型骗过 useImperativeHandle，避免使用 forwardRef 也可以实现，实现如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyRef</span> &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">JsErr</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">IMyRef</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          ref.current?.sayHi();</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        调用Children的handleTest方法</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">myRef</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Children</span> = (<span class="hljs-params">&#123; myRef &#125;: &#123; myRef: Ref&lt;IMyRef&gt; &#125;</span>) =&gt; &#123;<br>  <span class="hljs-comment">// myRef并不是ref传递的，是通过props传递的，这样就避免使用forwardRef了</span><br>  <span class="hljs-keyword">const</span> handleTest = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>  &#125;, []);<br>  <span class="hljs-title function_">useImperativeHandle</span>(myRef, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">sayHi</span>: handleTest,<br>  &#125;));<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js闭包</title>
    <link href="/2022/08/03/closure/"/>
    <url>/2022/08/03/closure/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>本文是从内存管理的角度来理解闭包的，因此会有一些前置知识需要建立</p><h3 id="js-运行原理"><a href="#js-运行原理" class="headerlink" title="js 运行原理"></a>js 运行原理</h3><p>js 是一门解释执行语言，因此在执行前会进行解释，解释完成后才会执行，注意它并不是等所有的代码都解释完后才执行的，而是边解释边执行的。</p><ul><li>对于下文代码，js 先只会解释 foo 函数和 fn 变量，然后执行 foo 函数，执行 foo 函数过程中遇到 bar 函数，再解释 bar 函数，进而执行，并不是把 foo bar fn 都解释完成后再执行代码<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;sunshine&quot;</span>;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bar;<br>&#125;<br><span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure></li><li>解释变量的过程，就是给变量赋值了一个 undefine 值，之后执行的时候才会进行真正的赋值操作</li><li>解释函数的过程，遇到函数，会在堆内存上创建内存空间，内存空间上存储两部分内容，第一个是函数的 parent_scope(父级作用域)，另一个是函数的执行代码。<font color="red">也就是说函数的父级作用域是在函数定义的时候指明，而不是函数调用的时候确定。</font> foo 函数定义的时候的作用域是全局，故打印的 foo 而不是 bar<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;bar&quot;</span>;<br>  <span class="hljs-title function_">foo</span>();<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// foo</span><br></code></pre></td></tr></table></figure></li><li>js 代码在具体执行的过程中，会运行在函数执行栈里，处于全局的变量和函数运行在全局执行上下文，每一个具体函数中运行的是函数执行上下文，每一个执行上下文由三部分构成，VO:变量对象，scope_chain:作用域链由自己的 VO 对象和父级作用域确定，以及执行时运行的执行代码(前两者解析函数时确定，后者执行时确定)。</li><li>js 查找变量是按照作用域链查找的</li></ul><h2 id="闭包运行分析"><a href="#闭包运行分析" class="headerlink" title="闭包运行分析"></a>闭包运行分析</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;cy&quot;</span>;<br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">24</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><p>上面的代码 name 和 function bar 就构成了一个闭包，具体的运行过程见下图<img src="/pic/closure/closure.png">.</p><ol><li><p>函数全局解析时，遇到 函数 foo 时会在堆上创建 foo 对象，对象存储了 foo 的父级作用域也就是全局作用域 GO(Global Object) 和代码体 <font color = "red">定义函数时确定父级作用域</font>，遇到 fn 的时候进行解析，在 GO 对象上添加属性 fn 值为 undefined</p></li><li><p>解析完毕执行代码，执行 foo 函数，执行函数会创建函数执行上下文，并将执行上下文入函数执行栈，函数执行栈里确定 VO(Variable Object)：也就是当前函数内部的变量对象，取名叫激活对象 AO(Active Object),开始解析函数内部变量，AO 解析时 name 和 age 都是 undefined,遇到 function bar 继续解析在堆上开辟内存空间地址是 0x20，确定父级作用域 foo 的 AO，和代码体。</p></li><li><p>执行 foo 内部代码进行赋值操作 foo AO 中的 name 和 age 变为“cy” 和 24,返回 bar 函数给全局里的 fn，实际返回的是函数在堆上的地址，故而 GO 中的 fn 就变成了 0x20,foo 函数执行完毕，出栈，foo 的执行上下文销毁。<font color = "red">这时候 foo 的 AO 并没有销毁,因为解析函数时 bar 的 parent_scope 引用这 foo 的 AO</font>。</p></li><li><p>继续执行 fn()，创建函数执行上下文，AO 是 bar 自己的包括传递的实参和自己内部的变量，scope_chain 是 bar 的 AO+parent_scope:foo 的 AO 。解析完毕开始执行代码 <code>console.log(name)</code> name 变量沿着作用域链查找，bar 的 AO 上没有，就往上查找在 foo 的 AO 上查找，继续往上找，找到 GO 没有就会报错，这里找到 foo 的 AO 上就找到了就直接打印出来了。函数执行完毕函数出栈。</p></li><li><p>这里 bar 函数和外层的 name 就构成了闭包。</p></li></ol><p>也就是说：js 中的函数如果访问了外层作用于的变量，那它们就构成了一个闭包。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>闭包往往很容易引起内存泄漏，继续以上文的例子为例，上面的代码执行完毕后，GO 中的 fn 持续引用这 bar 函数，bar 持续引用这 foo 的 AO，如果 js 中类似这样的引用很多，垃圾回收不能回收，就会造成内存泄漏的问题，因此为了解决这个问题，<font color = "red">对于不使用的函数，将其引用赋值为 null</font>，这样 bar 的引用消失，bar 就会在下次垃圾回收时销毁，接着 foo 的 AO 也就销毁了。</p><p>注意： 上文例子中 V8 对闭包也有优化，foo 中 AO 的 name 保留了，age 由于没有被使用，V8 将其销毁了以节约性能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js高级系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript高级类型</title>
    <link href="/2022/08/02/ts-learning/"/>
    <url>/2022/08/02/ts-learning/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><p><code>Record&lt;K,V&gt;</code> 创建一个以 K 为属性的类型，以 V 为值类型的对象。</p><ul><li>使用 Record 快速创建具有约束性质的对象类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ISubject</span> = <span class="hljs-string">&quot;Math&quot;</span> | <span class="hljs-string">&quot;Chinese&quot;</span> | <span class="hljs-string">&quot;English&quot;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IGrade</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">ISubject</span>, <span class="hljs-built_in">number</span>&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">myGrade</span>: <span class="hljs-title class_">IGrade</span> = &#123;<br>  <span class="hljs-title class_">Math</span>: <span class="hljs-number">99</span>,<br>  <span class="hljs-title class_">Chinese</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-title class_">English</span>: <span class="hljs-number">99</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h2><p><code>Partial&lt;T&gt;</code> T 是一个对象类型，这是取 T 这个对象的部分键值对作为属性，原理如下：</p><ul><li>keyof 是取对象类型的所有的属性 in 是取其中属性之一</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IPartial</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">mathGrade</span>: <span class="hljs-title class_">IPartial</span>&lt;<span class="hljs-title class_">IGrade</span>&gt; = &#123;<br>  <span class="hljs-title class_">Math</span>: <span class="hljs-number">100</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Record 结合 Partial 实现 AB 对象合并,A 对象如果有 B 对象的值就替换 B 对象</li><li>A 对象是 B 对象的一部分故而就是 Partial 实现，T 也需要泛型约束</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IMerge</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  sourceObj: Partial&lt;T&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  targetObj: T</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> T;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ITargetObj</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hhhh&quot;</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">999</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">merge</span>: <span class="hljs-title class_">IMerge</span>&lt;<span class="hljs-title class_">ITargetObj</span>&gt; = <span class="hljs-function">(<span class="hljs-params">sourceObj, targetObj</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> targetObj) &#123;<br>    <span class="hljs-keyword">const</span> itemVal = sourceObj[key];<br>    itemVal &amp;&amp; (targetObj[key] = itemVal);<br>  &#125;<br>  <span class="hljs-keyword">return</span> targetObj;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h2><p>extends 的使用</p><ul><li>如果在泛型<code>&lt;&gt;</code>中使用就是表示泛型约束 比如<code> &lt;T extends Record&lt;string,any&gt;&gt;</code>表示的是传入的泛型 T 必须是属性是字符串，值任意类型的对象</li><li>如果 extends 紧跟泛型后面就表示条件类型,T 继承 U 那么结果就是 X 类型，否则就是 Y 类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test</span>&lt;T, U, V&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; ? U : V;<br></code></pre></td></tr></table></figure><h2 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h2><p>infer 表示在 extends 条件语句中待推断的类型变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ParamType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (<span class="hljs-attr">arg</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : T;<br></code></pre></td></tr></table></figure><ul><li>在这个条件语句 T extends (arg: infer P) &#x3D;&gt; any ? P : T 中，infer P 表示待推断的函数参数。 整句表示为：如果 T 能赋值给 (arg: infer P) &#x3D;&gt; any，则结果是 (arg: infer P) &#x3D;&gt; any 类型中的参数 P，否则返回为 T。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Func</span> = <span class="hljs-function">(<span class="hljs-params">user: User</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Param</span> = <span class="hljs-title class_">ParamType</span>&lt;<span class="hljs-title class_">Func</span>&gt;; <span class="hljs-comment">// Param = User</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">AA</span> = <span class="hljs-title class_">ParamType</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p><code>ReturnType&lt;T&gt;</code> 表示函数返回值的类型，实现原理如下</p><ul><li>T 如果是这个函数，则把函数返回值的类型导出即可，这里使用到了 infer，infer 是等待推断的类型，这里需要推断的类型是返回值的类型，就是把 infer 的值当做一个变量来使用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span><br>) =&gt; infer R<br>  ? R<br>  : <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端debug</title>
    <link href="/2022/08/01/debug/"/>
    <url>/2022/08/01/debug/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>本文仅整体一些本人之前不曾了解过的 chrome 调试技巧</p><h2 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h2><ol><li>调试样式：先选中对应调试的元素</li><li>样式区选中.cls 动态选中需要选择的类<img src="/pic/debug/1.png"></li><li>选中:hover 区域，只调试伪类选择器对应的 css 效果<img src="/pic/debug/2.png"></li><li>选中 computed 计算区的 filter 进行快速筛选某个属性，筛选到对应的属性后选中旁边的小箭头可以快速跳转到 styles 区域下的类下面的样式<br><img src="/pic/debug/3.png"></li></ol><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><ol><li>不同类型的值，日志颜色不同，数值是紫色，字符串是青色</li><li><code>console.table()</code> 打印数组和对象以表格方式展开便于观察</li><li><code>console.dir()</code> 展开文件树结构，适合打印 DOM 节点上具有的属性</li><li><code>console.error() console.warning()</code>较为显眼的日志打印技巧</li><li>添加占位符实现某种样式打印控制台的结果<img src="/pic/debug/4.png"></li></ol><h2 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h2><ol><li>代码里直接写<code>debugger</code> 或者直接在 sources 面板下的 js 中选中具体的行，进行打断点，刷新浏览器进行 debugger.</li><li>右侧的 watch 直接监视需要查看的变量</li><li>BreakPoints 有多个断点时可以快捷取消选中断点</li><li>Scope：作用域：可以观察函数执行作用域和闭包</li><li>callStack：函数执行栈</li><li>XHR&#x2F;fetch BreakPoints 区域添加指定请求的 url,当请求发生的时候会触发断点<img src="/pic/debug/5.png"></li><li>线上代码调试技巧，打包的时候 webpack 开启 sourcemap，这样会生成 sourcemap，部署的时候只部署源代码，sourcesmap 文件存放到监控系统，这样线上报错的时候，监控系统会根据 sourcemap 指明源代码具体报错的代码行位置。<ul><li>也可以使用代理工具进行简单使用 sourcemap，代理工具将访问线上的 sourcemap 代理到本地的 sourcemap 上也可以进行线上调试。</li></ul></li></ol><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><ol><li>waterfall 区域可以观察请求是否是串行还是并行执行,第一个标记区域发现对齐的，所以是并行请求，第二个选中区域是错开的，故而是串行请求<br><img src="/pic/debug/6.png"></li></ol><h2 id="Performance-、LightHouse"><a href="#Performance-、LightHouse" class="headerlink" title="Performance 、LightHouse"></a>Performance 、LightHouse</h2><ol><li><p><a href="https://googlechrome.github.io/devtools-samples/jank/">chrome 提供的性能调试例子</a>，在 performance 区域进行录制分析。</p></li><li><p>以页面出现卡顿为例，录制后打开 Frames 下滑动鼠标滚轮明显发现掉帧现象，选中 Main 展开滑动滚轮放大后发现有红色区域，点击红色区域下面的 Summary 区域的 Callstacks 下会指出可能出现性能问题的文件，点击进行查看分析即可。</p><p><img src="/pic/debug/7.png">.<br><img src="/pic/debug/8.png"><br><img src="/pic/debug/9.png"><img src="/pic/debug/10.png"><br><img src="/pic/debug/11.png"></p></li><li><p>LightHouse 是 performance 的“简洁版”，用可以量化的分数来评判网站的性能</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>debug</tag>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器工作原理</title>
    <link href="/2022/07/30/browser/"/>
    <url>/2022/07/30/browser/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="浏览器输入-URL-的基本过程"><a href="#浏览器输入-URL-的基本过程" class="headerlink" title="浏览器输入 URL 的基本过程"></a>浏览器输入 URL 的基本过程</h2><p>传统的 SSR：用户在浏览器输入 url，经过 DNS 服务器解析为 ip 地址，向服务器发送 GET 请求，服务器最终返回 index.html 这个文件给客户端也就是浏览器<br>工作原理见下图</p><p><img src="/pic/browser/dns.png"></p><h2 id="浏览器解析-HTML-的过程"><a href="#浏览器解析-HTML-的过程" class="headerlink" title="浏览器解析 HTML 的过程"></a>浏览器解析 HTML 的过程</h2><p>浏览器并不是获得 index.html 就立即下载了对应的 css 文件<code>&lt;link href&gt;&lt;/link&gt;</code>，js 文件<code>&lt;script src&gt;&lt;script&gt;</code>，而是随着 index.html 的一行一行的执行遇到了对应的 link 标签和 script 标签才开始向服务器下载这些资源。css 和图片视频等都属于静态资源。浏览器的引擎分为两部分，一部分是渲染引擎，一部分是 js 引擎，渲染引擎待 css 和 html 整合成渲染树以后，将此渲染到页面上。js 引擎负责处理的就是将 js 代码转为机器码在 CPU 中最后执行的过程。解析过程见下图</p><p><img src="/pic/browser/render.png"></p><h2 id="js-引擎解析-js-过程"><a href="#js-引擎解析-js-过程" class="headerlink" title="js 引擎解析 js 过程"></a>js 引擎解析 js 过程</h2><p>常用的 js 引擎就是 chrome 的 v8 内核，这里以 v8 内核指代。</p><p><img src="/pic/browser/js-execu.png"><br>v8 内核先对 js 文件进行预解析，生成 GO 对象(GlobalObject)，存放 js 内置的对象比如说 String Date 以及 js 文件中初始化的变量，比如说<code>var name = &quot;hhhh&quot;</code>中的 name 变量等（注意这时候 js 还并没有执行，因此还没有进行赋值操作，故而此时 name 的值为 undefined—这就是变量提升的来源）。生成全局的 GO 之后将 js 文件的代码转为 AST（抽象语法树）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Vue 中的 template 模板引擎也是转为 ast 的">[1]</span></a></sup>,为了跨平台的需求会将 AST 转化为字节码<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="mac linux windows 的 cpu 执行指令不同，即同一段程序的机器码不同，故而先转化为字节码再转为机器码来实现跨平台">[2]</span></a></sup>，再转为机器码，最终执行，但是 V8 引擎为了做到高效的执行，在预解析形成 GO 全局对象的阶段时将所有存在的变量已经存储于 GO 中，在 AST 转化时进行词法分析，对于高频使用的函数，会进行直接转化为机器码，这样再以后执行的时候直接调用机器码执行，性能会大幅度提升。注意到有时候直接转为机器码之后反而又转为了字节码是因为以下原因：以前执行一直都是两个数相加，一直使用机器码没有问题，但是一旦输入两个字符串之后，这就会发生改变所以就有了 deoptimise 的过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Vue 中的 template 模板引擎也是转为 ast 的<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>mac linux windows 的 cpu 执行指令不同，即同一段程序的机器码不同，故而先转化为字节码再转为机器码来实现跨平台<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>js高级系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react admin权限设计</title>
    <link href="/2022/07/15/react-admin-design/"/>
    <url>/2022/07/15/react-admin-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>react admin 权限控制方案大体上有两种方案：前端控制路由表和后端控制路由表</p><h2 id="前端控制路由"><a href="#前端控制路由" class="headerlink" title="前端控制路由"></a>前端控制路由</h2><p>前文<a href="https://sunburst89757.github.io/my-blogs/blog/react-login-design">react-ts-admin 路由权限设计方案</a>的权限是由前端控制的路由表，根据后端给予当前用户的角色，在前端生成对应路由表来实现权限管理（权限管理方案基于<a href="https://github.com/PanJiaChen/vue-element-admin">vue-element-admin</a>的权限管理方案），但是此种方案缺点明显</p><ul><li>每个用户对应的角色生成的路由表由前端固定，一旦后期新增角色，需要重新部署前端应用。</li><li>用户对应角色的映射路由表的生成方式不够灵活。</li><li>此种方案需要前端手动注册所有的路由，router 书写繁杂</li></ul><h2 id="后端控制路由"><a href="#后端控制路由" class="headerlink" title="后端控制路由"></a>后端控制路由</h2><h3 id="前端动态注册路由"><a href="#前端动态注册路由" class="headerlink" title="前端动态注册路由"></a>前端动态注册路由</h3><ol><li><p>后端根据用户直接返回当前用户的可访问路由 accessRoutes(后端可以根据角色映射),前端根据返回的路由动态生成对应的组件。如此，当用户访问当前用户不允许访问的路由，由于前端根本没有注册这种路由，因此直接就会匹配到*,重定向 404，因此实现页面权限管理。</p></li><li><p>实现时需要考虑几个问题</p><ul><li>系统在后端获取可访问的路由时，需要注册几个基本的路由，比如 &#x2F;login 等页面</li><li>动态生成路由组件，必须使系统重新渲染，故而路由组件必须存储在 store 内（本文使用 redux）</li><li><font color="red">刷新带来的问题</font></li><li>一旦在用户的权限页面（后端返回的可访问页面）刷新必然会导致 store 里维护的路由组件置空，刷新后的页面重新访问改页面，路由组件没有注册必然系统崩溃。<ul><li>思路一：在路由拦截组件内部，根据某个状态条件判断，重新获取 accessRoutes，但是此方法只适用于 vue-router，因为 vue-router 的拦截器是全局的，不需要确定当前路由是否注册就进入路由拦截；但是 react router 的拦截组件是在当前路由注册的条件下进行拦截，因此路由不注册，不可能进行拦截组件内部重新获取可访问路由，因此此方案不可行。</li><li>思路二：由于 react-router 拦截组件是在路由注册时才能够实现拦截，故可以于登录后生成 accessRoutes，并存储于缓存里，刷新后从缓存里读取 accessRoutes 注册路由来实现访问，但是从缓存读取的 accessRoutes 经 useRoutes 注册<font color = "red">提示失败，原因未知,后续研究</font></li></ul></li></ul></li><li><p>实现细节—根据思路二实现</p><ul><li><p>路由配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//  路由配置 ---类似如下</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyLayout</span>&gt;</span></span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;布局&quot;</span>,<br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;dashboard&quot;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LazyLoad</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/Dashboard&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LazyLoad</span>&gt;</span></span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;首页&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>];<br><span class="hljs-comment">//  生成react router dom 6需要的结构</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateRouterForReactRouter</span> = (<span class="hljs-params">routes: RouteObject[]</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (route.<span class="hljs-property">children</span>) &#123;<br>      route.<span class="hljs-property">children</span> = <span class="hljs-title function_">generateRouterForReactRouter</span>(route.<span class="hljs-property">children</span>);<br>    &#125;<br>    <span class="hljs-comment">// 路由拦截器 登录和授权页面不需要鉴权</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInterceptRoute</span>(route)) &#123;<br>      route.<span class="hljs-property">element</span> = (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterBeforeEach</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;route.meta.title&#125;</span>&gt;</span></span><br><span class="language-xml">          &#123;route.element&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">RouterBeforeEach</span>&gt;</span></span><br>      );<br>    &#125;<br>    <span class="hljs-keyword">return</span> route;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>登录后获取后端生成路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">run</span>: handleLogin &#125; = <span class="hljs-title function_">useRequest</span>(<br>  <span class="hljs-function">(<span class="hljs-params">params: userType</span>) =&gt;</span> <span class="hljs-title function_">login</span>(params),<br>  &#123;<br>    <span class="hljs-attr">manual</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">onSuccess</span>: <span class="hljs-keyword">async</span> (res) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">success</span>) &#123;<br>        cache.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;token&quot;</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);<br>        <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: userRoutes &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserRoutes</span>();<br>        <span class="hljs-keyword">const</span> accessRoutes =<br>          <span class="hljs-title function_">generateAccessRoutesForReactRouter</span>(userRoutes);<br>        cache.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>, accessRoutes);<br>        <span class="hljs-title function_">dispatch</span>(gener);<br>        <span class="hljs-title function_">navigate</span>(<span class="hljs-string">&quot;/dashboard&quot;</span>);<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error, <span class="hljs-string">&quot;错误信息&quot;</span>);<br>    &#125;,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure></li><li><p>注册路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyRoutes</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">myRouter</span>: <span class="hljs-title class_">RouteObject</span>[] = [];<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<br>    <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span><br>  );<br>  <span class="hljs-comment">// 已经成功登录后 路由从store里读取</span><br>  <span class="hljs-keyword">if</span> (accessRoutes.<span class="hljs-property">length</span> &gt; <span class="hljs-number">2</span>) &#123;<br>    myRouter = accessRoutes;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 刷新后 accessRoutes会重置，路由就从缓存里读取，刷新路由重新进入刷新前的路由，在拦截器里重新获取accessRoutes</span><br>    myRouter = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> routes = <span class="hljs-title function_">useRoutes</span>(myRouter);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">100vh</span>&quot; &#125;&#125;&gt;</span>&#123;routes&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>路由拦截器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouterBeforeEach</span> = (<span class="hljs-params">&#123; children, title &#125;: interceptOBj</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span>);<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <span class="hljs-comment">// 验证是否登录（刷新）</span><br>  <span class="hljs-keyword">const</span> authLogin = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//获取用户的角色 菜单路由 权限信息</span><br>      <span class="hljs-keyword">if</span> (accessRoutes.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-comment">//   刷新导致store数据丢失，重新获取</span><br>        <span class="hljs-title function_">getUserRoutes</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span>  accessRoutes = <span class="hljs-title function_">generateAccessRoutesForReactRouter</span>(res.<span class="hljs-property">data</span>);<br>      &#125;<br>    &#125;)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;, []);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;authLogin?children:<span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>前文<a href="https://sunburst89757.github.io/my-blogs/blog/react-login-design#%E4%B8%80react-router-%E4%B8%8E-vue-router-%E7%9A%84%E5%8C%BA%E5%88%AB">react-ts-admin 路由权限设计方案</a>已详细说明，这里不再赘述。</p><h3 id="前端注册全部路由"><a href="#前端注册全部路由" class="headerlink" title="前端注册全部路由"></a>前端注册全部路由</h3><ol><li><p>由于前面方案刷新后缓存读取的 routes 配置不能够在 useRoutes 里生效，因此选择了前端手动注册全部路由，根据后端返回的路由生成一个可访问的路由进行鉴权来生成 404。</p></li><li><p>实现时考虑的问题</p><ul><li><p>前端手动注册全部路由，因此需要在路由拦截组件里除了需要判断是否登录，也需要进行逻辑校验是否有权限，无权限进入 404 的判断。</p></li><li><p>逻辑校验权限需要后端发送可访问的路由，这个请求存放的位置需要思考</p><ul><li>思路一：登录的时候直接发送这个请求，将获取的 accessRoutes 由 store 维护，避免刷新时造成 store 丢失存于缓存，但是刷新后 store 丢失的数据还需要及时获取,思路是直接存放于拦截器里再一次请求恢复 store，但是 authRoute 维护就从缓存里读取，避免计算过慢直接返回 404 了。</li><li>思路二：将请求直接存放于 layout 组件，layout 不需要鉴权，并且刷新的每一个页面都是 layout 作为一级组件，就避免了 login 和拦截组件的两次请求冗余，并且也不会让登陆页面请求过多造成页面渲染阻塞</li></ul></li></ul></li><li><p>实现细节</p><ul><li><p>注册路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; myRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./config&quot;</span>;<br><br><span class="hljs-comment">// 注册所有路由</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyRoutes</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> routes = <span class="hljs-title function_">useRoutes</span>(myRouter);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">100vh</span>&quot; &#125;&#125;&gt;</span>&#123;routes&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>layout 获取可访问路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyLayout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useAppDispatch</span>();<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<br>    <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span><br>  );<br>  <span class="hljs-comment">// 首次渲染执行  刷新时重新获取</span><br>  <span class="hljs-title function_">useAsyncEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (accessRoutes.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: menuRoutes &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserMenuList</span>();<br>      <span class="hljs-keyword">const</span> realMenuRoutes = <span class="hljs-title function_">generateAccessRoutes</span>(menuRoutes);<br>      <span class="hljs-keyword">const</span> siderRoutes = <span class="hljs-title function_">generateRouterForBackEnd</span>(menuRoutes);<br>      cache.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>, realMenuRoutes);<br>      <span class="hljs-comment">// 生成菜单路由</span><br>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addRoutes</span>(siderRoutes));<br>      <span class="hljs-comment">// 生成可以访问的路由结构</span><br>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">updateAccessRoutes</span>(realMenuRoutes));<br>    &#125;<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">100vh</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">MyHeader</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggle&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyHeader</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">MySider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MySider</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">MyContent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyContent</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>拦截器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouterBeforeEach</span> = (<span class="hljs-params">&#123; children, title &#125;: interceptOBj</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-title function_">useAppSelector</span>(<br>    <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">permission</span>.<span class="hljs-property">accessRoutes</span><br>  );<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <span class="hljs-comment">// 验证是否登录</span><br>  <span class="hljs-keyword">const</span> authLogin = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;, []);<br>  <span class="hljs-keyword">const</span> authRoute = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> accessRoutes.<span class="hljs-title function_">includes</span>(location.<span class="hljs-property">pathname</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;accessRoutes&quot;</span>).<span class="hljs-title function_">includes</span>(location.<span class="hljs-property">pathname</span>);<br>  &#125;, [location.<span class="hljs-property">pathname</span>, accessRoutes]);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;authLogin ? (</span><br><span class="language-xml">        authRoute ? (</span><br><span class="language-xml">          children</span><br><span class="language-xml">        ) : (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">        )</span><br><span class="language-xml">      ) : (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>react-router6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串操作方法总结</title>
    <link href="/2022/07/05/stringMethod/"/>
    <url>/2022/07/05/stringMethod/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>只有引用对象类型才具有属性和方法，string 作为原始值是不会拥有对应的属性和方法的，但是使用<code>&quot;abc&quot;.indexof(&quot;a&quot;)</code>是可以正常执行的。这是什么原因呢？</p><ol><li><p>js 给 string 做了原始封装类型 String（大写）,在使用<code>let str = &quot;abc&quot;;str.indexof(&quot;a&quot;)</code>的过程中执行了以下几个步骤</p><ul><li><code>let str = new String(&quot;abc&quot;) </code> 创建了 String 类型的实例</li><li>实例调用对应的方法和属性 <code>str.indexof(&quot;a&quot;)</code></li><li>销毁这个实例 <code>str = null</code></li></ul></li><li><p>声明字符串可以使用字面量声明也可以使用构造函数声明，但建议使用声明字符串的形式声明，避免类型上造成混乱理解不清。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC&quot;</span>; <span class="hljs-comment">// 推荐写法</span><br><span class="hljs-keyword">const</span> str1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// 不推荐</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// false</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span><br><span class="hljs-keyword">typeof</span> str; <span class="hljs-comment">// string</span><br><span class="hljs-keyword">typeof</span> str1; <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure></li><li><p>数值型和布尔型也有对应类似的 Number 和 Boolean 原始类型，使用上和注意事项与 String 相同。</p></li></ol><h2 id="String-常用操作方法"><a href="#String-常用操作方法" class="headerlink" title="String 常用操作方法"></a>String 常用操作方法</h2><h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><p><code>substring(start,end)</code>和 <code>slice(start,end)</code> 方法,都是返回一个新的字符串，不修改原字符串，从起点开始，不包括终点。<font color = "red">推荐使用 substring</font></p><ul><li>当 end 为负数时<ul><li>对于 substring 来说视为 0，自动将两个参数按照大小顺序互换</li><li>对于 slice 来说负数视为字符串的长度+ 负数视为 end 然后按照大小顺序互换</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abcd&quot;</span>;<br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// ab</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//a</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt;str.substring(0,2) ab</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt;str.slice(2,1) =&gt;str.slice(1,2) b</span><br></code></pre></td></tr></table></figure><h3 id="字符串位置"><a href="#字符串位置" class="headerlink" title="字符串位置"></a>字符串位置</h3><p><code>indexof(char, start)</code> <code> lastIndexof(char,start)</code>第一个顺序从 start 查找 char 字符，找到就停止；第二个是末尾从头查找 char 字符，查到停止。</p><ul><li><p>查找字符串中所有对应的 char 字符:找到之后序号加一继续向下找即可</p></li><li><p><font color = "red">既能寻找一个字符”a”也能寻找类似”ab”这种</font></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchAllChar</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, target: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span> = str.<span class="hljs-title function_">indexOf</span>(target, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">while</span> (position &gt;= <span class="hljs-number">0</span>) &#123;<br>    arr.<span class="hljs-title function_">push</span>(position);<br>    position = str.<span class="hljs-title function_">indexOf</span>(target, position + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="字符串包含"><a href="#字符串包含" class="headerlink" title="字符串包含"></a>字符串包含</h3><p><code>includes(str,start)</code> 从 start 开始搜寻，匹配到 str 就返回 true</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;foobarbaz&quot;</span>;<br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// true</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="字符串母大小写"><a href="#字符串母大小写" class="headerlink" title="字符串母大小写"></a>字符串母大小写</h3><p><code>toLowerCase()</code> 全部替换小写 <code>toUpperCase()</code> 全部替换大写</p><h3 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h3><p><code>trim()</code>去除字符串前后空格，不改变原字符串</p><h3 id="字符串转数组方法"><a href="#字符串转数组方法" class="headerlink" title="字符串转数组方法"></a>字符串转数组方法</h3><ol><li><p>利用字符串解构实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...str]); <span class="hljs-comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>split()</code>方法，接收一个参数，以间隔的形式分割字符串形成数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str1</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;1.1.1&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)); <span class="hljs-comment">// [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h3><ol><li><code>match()</code> 接收一个参数：正则表达式，返回值同 RegExp 对象的<code>exec()</code>方法的返回值相同。</li><li><code>search()</code> 接收正则表达式，返回找到的第一个字符的位置。<ul><li>与<code>indexOf()</code> 的区别是 search 可以通过正则查询</li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;cat bat sat&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span> = text.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/at/</span>); <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>replace()</code> 方法替换字符串方法，接收两个参数。第二个参数是字符串，替换第一个参数的值。<ul><li>第一个是字符串，第二个字符串替换第一个字符串，只能替换一个。</li><li>第一个是正则，第二个字符串，当正则有全局匹配时才会替换用第二个字符串替换全局。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript高级程序设计读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/06/27/binarySearch/"/>
    <url>/2022/06/27/binarySearch/</url>
    
    <content type="html"><![CDATA[<!--truncate--><p>本文理解基于此<a href="https://labuladong.github.io/algo/1/10/">labuladong 算法小抄</a></p><h2 id="寻找指定目标"><a href="#寻找指定目标" class="headerlink" title="寻找指定目标"></a>寻找指定目标</h2><ol><li><p>场景：有序无重复数组寻找 target。</p></li><li><p>基本原理：寻找有序数列当中的中间值，与中间值作比较，不断收缩序列大小直至找到目标值</p><ul><li>选择闭区间[left,right]就要表明 right 是能够取到的值，所以 right 的初值是 nums.length - 1 不是 nums.length;</li><li>因为[]区间闭合，所以 left&lt;&#x3D;right，区间的右边 left 是可以取到的，所以有等号</li><li>middle 不取(left+right)&#x2F;2 是因为，数据的存储是有上限的，避免数值整型溢出。</li><li>如果目标值比中间值要大，显然 target 位于(middle,right],所以要更新 left，已经验证过 nums[middle] !&#x3D;&#x3D; target,因此 left 更新值比 middle 大一，right 的更新同理。</li><li><font color="red">退出循环的条件:left &#x3D; right + 1</font></li><li>当二分查找最终都查不出来的时候就返回-1</li></ul></li><li><p>代码实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTarget</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//   右边界取数组的最右侧边是[left,right] 闭区间，所有的点都可取到</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//   因为所有的点都可以取到所以可以取等号</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-comment">//    防止溢出边界</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">middle</span>: <span class="hljs-built_in">number</span> = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-keyword">return</span> middle;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="寻找左右边界"><a href="#寻找左右边界" class="headerlink" title="寻找左右边界"></a>寻找左右边界</h2><ol><li><p>场景： 有序数组，但内部数值序列有重复的情况。</p></li><li><p>基本原理：在二分查找的时候不断收缩左右边界，直至找到。</p><ul><li>大体遍历和上面的原理相同，只是在等于目标值的处理方式不同。<ul><li>寻找左边界，碰到了目标值不代表结束，应该收缩边界，找左边界，那么就要让上限不断的向左靠近 所以就对 right &#x3D; middle - 1,同样的找有边界，就是 left &#x3D; middle + 1 靠近右边界。</li></ul></li><li><font color = "red">左边界的意义，比如说左边界是 2，就表明数组有 2 个数小于 target，通过二分的循环只能找到这一点，但是不能确定边界值是不是等于 target，所以需要出来要判断一下，除此之外需要判断一下是否存在遍历的时候溢出的情况，故而需要判断是否小于 0 是否溢出数组的边界</font></li><li>左右边界显然对应的就是 left 和 right 对应的对象。</li></ul></li><li><p>代码实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLeftBorder</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">middle</span>: <span class="hljs-built_in">number</span> = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-comment">// 收缩边界，寻找左边界，那么有边界需要不停的向左边收缩靠近</span><br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 边界溢出 和 实际的边界值和目标值没找到，就返回-1</span><br>  <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span> || left &gt;= nums.<span class="hljs-property">length</span> || nums[left] !== target) &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getRightBorder</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">middle</span>: <span class="hljs-built_in">number</span> = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-comment">// 收缩边界，寻找右边界，那么左边界需要不停的向右边收缩靠近</span><br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || right &gt;= nums.<span class="hljs-property">length</span> || nums[right] !== target) &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-ts-admin路由权限设计方案</title>
    <link href="/2022/06/06/react-login-design/"/>
    <url>/2022/06/06/react-login-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="一、react-router-与-vue-router-的区别"><a href="#一、react-router-与-vue-router-的区别" class="headerlink" title="一、react-router 与 vue-router 的区别"></a>一、react-router 与 vue-router 的区别</h2><ol><li>react-router 没有提高拦截器的 API 设计，因为为了权限拦截的功能，需要手动封装拦截组件，根据用户权限来决定是否渲染对应的路由组件。</li><li>vue-router 设计有动态添加路由的 api，因此可以在登录后通过角色权限的验证来动态添加权限路由，但是 react-router 并不存在动态添加路由的 api,因此必须 react 的路由组件必须在刚开始就全局注册好。根据指定的路由，在拦截组件里进行角色校验放行。</li><li>react-router 不存在类似 vue-router 对路由的配置方式，在 generateRouter 函数中将配置对象转化为 useRouts 接收的配置方式。</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateRouter</span> = (<span class="hljs-params">routes: RouteObject[]</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (route.<span class="hljs-property">children</span>) &#123;<br>      route.<span class="hljs-property">children</span> = <span class="hljs-title function_">generateRouter</span>(route.<span class="hljs-property">children</span>);<br>    &#125;<br>    <span class="hljs-comment">// 路由拦截器 登录和授权页面不需要鉴权</span><br>    <span class="hljs-keyword">if</span> (route.<span class="hljs-property">path</span> !== <span class="hljs-string">&quot;/login&quot;</span> &amp;&amp; route.<span class="hljs-property">path</span> !== <span class="hljs-string">&quot;/404&quot;</span>) &#123;<br>      route.<span class="hljs-property">element</span> = (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterBeforeEach</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&#123;route.meta.role&#125;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;route.meta.title&#125;</span>&gt;</span></span><br><span class="language-xml">          &#123;route.element&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">RouterBeforeEach</span>&gt;</span></span><br>      );<br>    &#125;<br>    <span class="hljs-keyword">return</span> route;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二、登录设计要点"><a href="#二、登录设计要点" class="headerlink" title="二、登录设计要点"></a>二、登录设计要点</h2><ol><li>登录流程：<ol><li>表单验证通过后发起登录请求，</li><li>根据获取的 role 权限，</li><li>生成对应的侧面菜单路由。</li></ol></li><li>react 的路由组件得全部注册（前端控制路由的方式），角色访问与否，在拦截组件中进行拦截。</li><li>菜单的注册方式<ol><li>配置路由时单独对应设计 siderRoutes 这个配置项。</li><li>在 sider 组件中对路由进行两次配置<ol><li>根据角色权限生成可访问的侧边路由</li><li>生成的侧边路由配置生成满足 antd 生成菜单对应的路由结构。</li></ol></li></ol></li><li>拦截组件的设计：类比 Vue-admin 的设计理念，token 做一次登录校验，角色做一次路由放行校验。</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouterBeforeEach</span> = (<span class="hljs-params">&#123; children, role, title &#125;: interceptOBj</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">useAppSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>);<br>  <span class="hljs-comment">// 验证是否登录（刷新）</span><br>  <span class="hljs-keyword">const</span> authLogin = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">// &#125; else &#123;</span><br>      <span class="hljs-comment">//   if (!userInfo.role) &#123;</span><br>      <span class="hljs-comment">//     // 说明没有获取用户的角色，第一次登录需要获取用户信息</span><br>      <span class="hljs-comment">//     dispatch(getUserInfoAction());</span><br>      <span class="hljs-comment">//   &#125;</span><br>    &#125;<br>    <span class="hljs-comment">// 不用考虑刷新，因为role已经数据持久化了刷新不会丢失</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;, []);<br>  <span class="hljs-comment">// 验证权限路由</span><br>  <span class="hljs-keyword">const</span> authRoute = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">//  配置路由时不传递或者说用户的角色是超级管理员时直接放行</span><br>    <span class="hljs-keyword">if</span> (!role || userInfo.<span class="hljs-property">role</span> === <span class="hljs-string">&quot;super-admin&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> role.<span class="hljs-title function_">includes</span>(userInfo.<span class="hljs-property">role</span>);<br>  &#125;, [role, userInfo.<span class="hljs-property">role</span>]);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;authLogin ? (</span><br><span class="language-xml">        authRoute ? (</span><br><span class="language-xml">          children</span><br><span class="language-xml">        ) : (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">        )</span><br><span class="language-xml">      ) : (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Redirect</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三、tabs-的设计"><a href="#三、tabs-的设计" class="headerlink" title="三、tabs 的设计"></a>三、tabs 的设计</h2><ol><li><p>tab 的设计探索见<a href="https://sunburst89757.github.io/my-blogs/blog/vue-login-design">vue 设计 tabs 和菜单联动</a></p></li><li><p>总原则：监视路由的变化实现 tab 和 menu 的联动。由于进行了跨组件通信，且状态数量过多，使用 redux 管理。</p></li><li><p>菜单点击路由跳转，tab 监听路由变化，生成新的 tab 或者 tab 跳转。</p></li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> matchRoute = <span class="hljs-title function_">matchRoutes</span>(siderRoutes, location.<span class="hljs-property">pathname</span>)!;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">newTab</span>: tabObject = &#123;<br>    <span class="hljs-attr">key</span>: matchRoute[matchRoute.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">pathname</span>,<br>    <span class="hljs-attr">title</span>: matchRoute[matchRoute.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">route</span>.<span class="hljs-property">meta</span>!.<span class="hljs-property">title</span>,<br>  &#125;;<br>  <span class="hljs-comment">// 解决直接关闭页面后，重新打开页面，生成一个/路径 ----对应的tab</span><br>  <span class="hljs-keyword">if</span> (newTab.<span class="hljs-property">title</span> === <span class="hljs-string">&quot;布局&quot;</span>) &#123;<br>    <span class="hljs-comment">// 有redux的数据持久化，因此直接找到离开前激活的页面进行跳转即可</span><br>    <span class="hljs-title function_">navigate</span>(tabActive);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeTab</span>(newTab));<br>  &#125;<br>&#125;, [location.<span class="hljs-property">pathname</span>, dispatch, navigate]);<br></code></pre></td></tr></table></figure><ol start="3"><li>tab 本身的操作，只处理 tab 本身，对 tab 进行增删跳转由 redux 管理 tabActive，真正实现路由跳转由对 tabActive 的监视实现。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue登录权限设计</title>
    <link href="/2022/05/29/vue-login-design/"/>
    <url>/2022/05/29/vue-login-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="一、登录流程"><a href="#一、登录流程" class="headerlink" title="一、登录流程"></a>一、登录流程</h2><ol><li><p>表单验证：验证账号和密码是否符合验证规则，验证通过后发起登录请求</p></li><li><p>这个登录只用于获取 token 注意：这里 token 必须存在缓存里—否则后面的刷新获取动态路由就失效了。</p></li><li><p>成功获取 token 后进行路由跳转</p></li><li><p>路由跳转执行路由守卫进行拦截</p><ol><li><p>不是去登录的路由，验证是否有 token，没有 token 就去登录</p></li><li><p>有 token 的情况</p><ol><li><p>在 pinia 下获取用户的角色，如果有角色，就直接放行</p></li><li><p>没有角色的情况 说明是第一次登录（或者是由于刷新导致的 role 丢失）。</p><ol><li><p>调取接口获取用户的详细信息：比如说用户名，id,role,图片，电话等信息。</p></li><li><p>根据用户的角色，映射生成可以访问的路由，进行动态路由注册，根据生成的可访问路由生成访问菜单。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">next</span>(&#123; ...to, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><h2 id="二、登录逻辑"><a href="#二、登录逻辑" class="headerlink" title="二、登录逻辑"></a>二、登录逻辑</h2><ol><li>原则：采取前端控制权限的方法，实现接口级权限，路由级权限，按钮级权限。</li><li>后端只需要发送用户 token 和对应的角色即可，前端根据写的路由中的 meta 信息生成当前角色可以访问</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue设计tabs和菜单联动</title>
    <link href="/2022/05/29/vue-tabs-design/"/>
    <url>/2022/05/29/vue-tabs-design/</url>
    
    <content type="html"><![CDATA[<!--truncate--><h2 id="总的原则"><a href="#总的原则" class="headerlink" title="总的原则"></a>总的原则</h2><p>监听路由的变化实现 menu 与 tabs 的双向绑定。</p><h2 id="menu-的实现"><a href="#menu-的实现" class="headerlink" title="menu 的实现"></a>menu 的实现</h2><ol><li>menu 只需要点击能够实现跳转路由即可，这里跳转的方式，使用 click 还是直接用 el-menu 组件自身的 route 模式，取决于路由跳转是使用命名路由还是 path 直接跳，方便的程度与否取决于生成的菜单的结构。</li><li>该系统的实现基于点击菜单事件实现路由跳转，跳转的方式是命名路由跳转。</li></ol><h2 id="tabs-的引入的三个方案"><a href="#tabs-的引入的三个方案" class="headerlink" title="tabs 的引入的三个方案"></a>tabs 的引入的三个方案</h2><p>三个方案的不同点只在于点击菜单，如何生成 tab 的改进，tab 上的切换实现都是相同的。</p><h3 id="tab-的存储原则"><a href="#tab-的存储原则" class="headerlink" title="tab 的存储原则"></a>tab 的存储原则</h3><p>tabs 的所有数据存储在 tabStore 里，主要就是 tabs tabsActive menuActive acheComponents(keep-alive 缓存的组件 name)</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><ol><li>原则：点击菜单项将 tab 需要的信息构造成新的 tab 或者在原 tab 里进行切换。</li><li>实现：<ul><li>点击菜单将菜单项对应的 title 和 path（实际是命名路由）构造新的 tab 给 tabStore.tabs 里，并进行路由跳转。</li><li>表现形式上体现切换到指定的 tab，就将 tabActive 转为新的路由组件对应的名字上即可<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessageToTabs</span> = (<span class="hljs-params">menuOption: tabType, event: <span class="hljs-built_in">any</span></span>) =&gt; &#123;<br>  menuActive.<span class="hljs-property">value</span> = event.<span class="hljs-property">index</span>;<br>  tabOption.<span class="hljs-property">title</span> = menuOption.<span class="hljs-property">title</span>;<br>  tabOption.<span class="hljs-property">path</span> = menuOption.<span class="hljs-property">path</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;tabOption&quot;</span>, tabOption);<br>  tabsStore.<span class="hljs-title function_">addTab</span>(menuOption);<br>  router.<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-attr">name</span>: menuOption.<span class="hljs-property">path</span>,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li>缺点：将 menu 组件和 tabs 组件高度绑定了，点击 menu 需要传递给 tabs 组件相应信息。</li></ol><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><ol><li>原则：tab 下存储的组件表现形式实际只是不同路由切换的结果，因此可以考虑分离 tab 和 menu 的耦合关系，点击 menu 只进行路由跳转，可以在 layout 组件下只监听路由变化即可，路由变化来考虑是否新增 tab。</li><li>实现<ul><li>layout 组件下监听 route，route 发生变化，route.name 和 route.meta.name 存储有构造 tab 的信息</li></ul></li><li>缺点：<ul><li>layout 组件监听 route 实现了菜单情况下 spa 页面的 tab 增加，但是在退出登录时会也监听到了 login 这个路由也会新增到 tabs 内部，下次登录的时候就会出现登录这个选项卡就会出现在 tab 栏里。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">watch</span>(route, <span class="hljs-function">(<span class="hljs-params">newRoute</span>) =&gt;</span> &#123;<br>  tabsStore.<span class="hljs-title function_">handleTab</span>(newRoute);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><ol><li>原则： 选择将路由变化放在路由拦截器里处理.</li><li>实现：路由拦截分为了以下几种情况，只需要在后两种情况下操纵 tab 即可，特殊情况如刷新，404 页面，route 都会匹配两次，也会操作 tab，这两种情况下第一次匹配都会出现 route.name 都是 undefined，再单独给 404 路由不设置 name，就可以实现只有 spa 与 tab 相关。</li></ol><ul><li>去登录页面</li><li>第一次来到首页（刷新页面）</li><li>正常的切换到不同的页面</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs ts">&lt;!-- 拦截器 --&gt;<br>  router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> token = cache.<span class="hljs-title function_">getCache</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> !== <span class="hljs-string">&quot;/login&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/login&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;查询to对象&quot;</span>, to);<br><br>      <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>();<br>      <span class="hljs-comment">// 登录或者刷新的时候</span><br>      <span class="hljs-keyword">if</span> (!userStore.<span class="hljs-property">role</span>) &#123;<br>        <span class="hljs-keyword">await</span> userStore.<span class="hljs-title function_">getUserRole</span>();<br>        <span class="hljs-title function_">generateAccessRoutes</span>(userStore.<span class="hljs-property">role</span>, asyncRoutes);<br>        <span class="hljs-comment">// 注册动态路由</span><br>        asyncRoutes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(element);<br>        &#125;);<br>        userStore.<span class="hljs-title function_">generateUserMenus</span>();<br>        <span class="hljs-comment">// 不使用 next() 是因为，在执行完 router.addRoute 后，</span><br>        <span class="hljs-comment">// 原本的路由表内还没有添加进去的路由，会 No match</span><br>        <span class="hljs-comment">// replace 使路由从新进入一遍，进行匹配即可</span><br>        <span class="hljs-title function_">next</span>(&#123; ...to, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">next</span>();<br>      &#125;<br>      <span class="hljs-title function_">generateMenuAndTab</span>(to);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">next</span>();<br>  &#125;<br>&#125;);<br>&lt;!-- handleTab --&gt;<br><span class="hljs-title function_">handleTab</span>(<span class="hljs-params">route: RouteLocationNormalizedLoaded</span>) &#123;<br>  <span class="hljs-comment">// 刷新时，因为没有动态注册路由，所以匹配不到路由，对应的path和name就都是undefined，这不能添加到tab上</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;zhixinghandle&quot;</span>, route);<br><br>  <span class="hljs-keyword">if</span> (!route.<span class="hljs-property">name</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isTabInTabs</span>(route.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">RouteRecordName</span>)) &#123;<br>    <span class="hljs-keyword">const</span> tab = &#123;<br>      <span class="hljs-attr">title</span>: route.<span class="hljs-property">meta</span>.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>,<br>      <span class="hljs-attr">path</span>: route.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">RouteRecordName</span><br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addTab</span>(tab);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 已有的tab，重置tab状态</span><br>    <span class="hljs-comment">// console.log(route.name, &quot;名字&quot;);</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tabActive</span> = <span class="hljs-title class_">String</span>(route.<span class="hljs-property">name</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">menuActive</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tabActive</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="tabs-的实现"><a href="#tabs-的实现" class="headerlink" title="tabs 的实现"></a>tabs 的实现</h2><ol><li><p>原则：真正菜单对应的路由组件并没有放在 el-tab-panel 下，watch 在通用布局组件 layout 下面监听 route，route 发生变化，说明 tab 会出现相应的变化操作。不同 tab 的页面应该处于缓存状态，所以应该用 keep-alive 缓存状态，但是在关闭 tab 的时候相应的也需要对不用的组件进行销毁，这里不采取 destroy 来销毁组件，采用对 router-view 使用 include 来选择包含的组件进行缓存，关闭 tab 就移出。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// layout.vue 在这个页面监听路由的变化</span><br>&lt;el-main <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;<br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-tabs&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">nav-tabs</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav-tabs</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123; Component &#125;&quot;</span> &gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span></span><br><span class="language-xml">           <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;cacheComponents&quot;</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;Component&quot;</span> /&gt;</span></span><br><span class="language-xml">           <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>     &lt;/el-main&gt;<br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();<br><span class="hljs-keyword">const</span> tabsStore = <span class="hljs-title function_">useTabStore</span>();<br><span class="hljs-keyword">const</span> &#123; cacheComponents &#125; = <span class="hljs-title function_">storeToRefs</span>(tabsStore);<br></code></pre></td></tr></table></figure></li><li><p>操作 Tab:Tab 的数据全部存储在 store&#x2F;tabStore 下</p><ul><li>handleTab: 将路由拦截的路由对象 to 传递过来判断即可，判断是否是新增还是跳转即可。</li></ul></li><li><p>删除 tab</p><ol><li>删除后，选中的路由应该是上一个 tab 对应的路由路径</li><li>删除最后一个自动对应首页对应的路由</li></ol></li><li><p>点击 tab 实现路由的切换管理：直接点击的时候实现路由跳转即可，修改菜单的选中状态即可实现。</p></li></ol><p>**<em>这里还存在问题：</em><strong>路由组件存放在 el-tab-pannel 下会出现下面情况，有几个 tab 页面，选中其中一个 tab 页，它对应的组件 setup 会执行几次；具体来说有三个 tab 页 a,b,c，点击 a，</strong><em>a 页面的 setup 会执行三次，具体情况未知待测</em>**。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
